<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protocolos Personalizados on Ingenium MX</title><link>https://ingeniummx.github.io/tags/protocolos-personalizados/</link><description>Recent content in Protocolos Personalizados on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 16 Mar 2024 13:00:00 +0200</lastBuildDate><atom:link href="https://ingeniummx.github.io/tags/protocolos-personalizados/index.xml" rel="self" type="application/rss+xml"/><item><title>Módulos PIO en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 13:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</guid><description>&lt;p&gt;Los &lt;strong&gt;módulos PIO (Programmable I/O)&lt;/strong&gt; del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-pio"&gt;Arquitectura PIO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Máquinas de estado:&lt;/strong&gt; hasta 4 por bloque, cada una con 32 instrucciones de 16 bits.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO TX/RX:&lt;/strong&gt; buffers de 4 palabras para intercambio con la CPU o DMA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins flexibles:&lt;/strong&gt; mapeo independiente para entrada, salida y side-set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock divider:&lt;/strong&gt; ajusta la frecuencia de ejecución con resolución fraccional.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-trabajo"&gt;Flujo de trabajo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Escribe el programa PIO en ensamblador específico (&lt;code&gt;.program&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Carga el código en la instrucción memory del bloque PIO.&lt;/li&gt;
&lt;li&gt;Configura los registros de control (SM, clocks, pins).&lt;/li&gt;
&lt;li&gt;Usa la API del SDK o MicroPython para enviar/recibir datos.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplos-prácticos"&gt;Ejemplos prácticos&lt;/h2&gt;
&lt;h3 id="ws2812-neopixel"&gt;WS2812 (NeoPixel)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Genera los pulsos de 800 kHz con side-set para controlar tiras RGB.&lt;/li&gt;
&lt;li&gt;Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interfaces-vgadvi"&gt;Interfaces VGA/DVI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas.&lt;/li&gt;
&lt;li&gt;Requiere DMA para alimentar los buffers a alta velocidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="captura-de-señales"&gt;Captura de señales&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura una máquina PIO en modo &lt;code&gt;IN&lt;/code&gt; para muestrear pines a alta frecuencia.&lt;/li&gt;
&lt;li&gt;Vuelca los datos a memoria mediante DMA para análisis posterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-de-implementación"&gt;Consejos de implementación&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Planifica el ancho de palabra.&lt;/strong&gt; Ajusta &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt; y shift registers para empaquetar datos eficientemente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Utiliza DMA.&lt;/strong&gt; Mantiene alimentadas las FIFOs sin bloquear la CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Divide funciones entre máquinas.&lt;/strong&gt; Un bloque puede generar reloj y otro manejar datos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura con &lt;code&gt;pioasm&lt;/code&gt;.&lt;/strong&gt; El SDK incluye herramientas para validar el programa antes de compilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincroniza con IRQ.&lt;/strong&gt; Usa interrupciones PIO para coordinar eventos con el firmware principal.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="recursos-adicionales"&gt;Recursos adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Documentación oficial del &lt;strong&gt;RP2040 Datasheet&lt;/strong&gt; (capítulo PIO).&lt;/li&gt;
&lt;li&gt;Ejemplos del &lt;strong&gt;Pico SDK&lt;/strong&gt; (&lt;code&gt;pio/&lt;/code&gt;): UART, I²C, PWM mejorado, DVI.&lt;/li&gt;
&lt;li&gt;Librerías comunitarias como &lt;strong&gt;rp2040-pio-emulator&lt;/strong&gt; para pruebas en PC.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.&lt;/p&gt;</description></item></channel></rss>