<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RP2040 on Ingenium MX</title><link>https://ingeniummx.github.io/tags/rp2040/</link><description>Recent content in RP2040 on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 16 Mar 2024 13:00:00 +0200</lastBuildDate><atom:link href="https://ingeniummx.github.io/tags/rp2040/index.xml" rel="self" type="application/rss+xml"/><item><title>Módulos PIO en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 13:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</guid><description>&lt;p&gt;Los &lt;strong&gt;módulos PIO (Programmable I/O)&lt;/strong&gt; del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-pio"&gt;Arquitectura PIO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Máquinas de estado:&lt;/strong&gt; hasta 4 por bloque, cada una con 32 instrucciones de 16 bits.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO TX/RX:&lt;/strong&gt; buffers de 4 palabras para intercambio con la CPU o DMA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins flexibles:&lt;/strong&gt; mapeo independiente para entrada, salida y side-set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock divider:&lt;/strong&gt; ajusta la frecuencia de ejecución con resolución fraccional.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-trabajo"&gt;Flujo de trabajo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Escribe el programa PIO en ensamblador específico (&lt;code&gt;.program&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Carga el código en la instrucción memory del bloque PIO.&lt;/li&gt;
&lt;li&gt;Configura los registros de control (SM, clocks, pins).&lt;/li&gt;
&lt;li&gt;Usa la API del SDK o MicroPython para enviar/recibir datos.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplos-prácticos"&gt;Ejemplos prácticos&lt;/h2&gt;
&lt;h3 id="ws2812-neopixel"&gt;WS2812 (NeoPixel)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Genera los pulsos de 800 kHz con side-set para controlar tiras RGB.&lt;/li&gt;
&lt;li&gt;Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interfaces-vgadvi"&gt;Interfaces VGA/DVI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas.&lt;/li&gt;
&lt;li&gt;Requiere DMA para alimentar los buffers a alta velocidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="captura-de-señales"&gt;Captura de señales&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura una máquina PIO en modo &lt;code&gt;IN&lt;/code&gt; para muestrear pines a alta frecuencia.&lt;/li&gt;
&lt;li&gt;Vuelca los datos a memoria mediante DMA para análisis posterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-de-implementación"&gt;Consejos de implementación&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Planifica el ancho de palabra.&lt;/strong&gt; Ajusta &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt; y shift registers para empaquetar datos eficientemente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Utiliza DMA.&lt;/strong&gt; Mantiene alimentadas las FIFOs sin bloquear la CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Divide funciones entre máquinas.&lt;/strong&gt; Un bloque puede generar reloj y otro manejar datos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura con &lt;code&gt;pioasm&lt;/code&gt;.&lt;/strong&gt; El SDK incluye herramientas para validar el programa antes de compilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincroniza con IRQ.&lt;/strong&gt; Usa interrupciones PIO para coordinar eventos con el firmware principal.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="recursos-adicionales"&gt;Recursos adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Documentación oficial del &lt;strong&gt;RP2040 Datasheet&lt;/strong&gt; (capítulo PIO).&lt;/li&gt;
&lt;li&gt;Ejemplos del &lt;strong&gt;Pico SDK&lt;/strong&gt; (&lt;code&gt;pio/&lt;/code&gt;): UART, I²C, PWM mejorado, DVI.&lt;/li&gt;
&lt;li&gt;Librerías comunitarias como &lt;strong&gt;rp2040-pio-emulator&lt;/strong&gt; para pruebas en PC.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.&lt;/p&gt;</description></item><item><title>Raspberry Pi Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</link><pubDate>Sat, 16 Mar 2024 11:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</guid><description>&lt;p&gt;La &lt;strong&gt;Raspberry Pi Pico&lt;/strong&gt; es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="especificaciones-esenciales"&gt;Especificaciones esenciales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microcontrolador:&lt;/strong&gt; RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria:&lt;/strong&gt; 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Periféricos:&lt;/strong&gt; 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación:&lt;/strong&gt; 1,8–5,5 V, regulador buck-boost integrado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos:&lt;/strong&gt; Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="fortalezas-del-rp2040"&gt;Fortalezas del RP2040&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PIO (Programmable I/O).&lt;/strong&gt; Motores de estado que permiten implementar protocolos personalizados a nivel de hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doble núcleo.&lt;/strong&gt; Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bajo costo y disponibilidad.&lt;/strong&gt; La placa base ronda los 4 USD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad y documentación amplia.&lt;/strong&gt; SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso-recomendados"&gt;Casos de uso recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controladores de robots educativos&lt;/strong&gt; gracias a su PWM abundante y soporte MicroPython.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces personalizadas&lt;/strong&gt; (DVI, VGA, audio PDM) mediante PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT económico&lt;/strong&gt; con el modelo Pico W y su módulo Wi-Fi CYW43439.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentos de laboratorio DIY&lt;/strong&gt; como generadores de señales y analizadores lógicos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-software"&gt;Ecosistema de software&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pico SDK (C/C++).&lt;/strong&gt; Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython y CircuitPython.&lt;/strong&gt; Repl inmediato, ideal para iterar rápido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TinyUSB.&lt;/strong&gt; Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bibliotecas de terceros.&lt;/strong&gt; Drivers para pantallas, sensores y motores mantenidos por la comunidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-proyectos"&gt;Consejos para proyectos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Usa el &lt;strong&gt;SMPS integrado&lt;/strong&gt; (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA.&lt;/li&gt;
&lt;li&gt;Aprovecha el &lt;strong&gt;debug por SWD&lt;/strong&gt; expuesto en los pads debajo de la placa.&lt;/li&gt;
&lt;li&gt;Para aplicaciones críticas, añade &lt;strong&gt;flash externa de calidad&lt;/strong&gt; y watchdog habilitado.&lt;/li&gt;
&lt;li&gt;Documenta la versión del SDK en tu repositorio para reproducibilidad.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.&lt;/p&gt;</description></item></channel></rss>