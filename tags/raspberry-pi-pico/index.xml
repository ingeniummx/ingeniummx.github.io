<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberry Pi Pico on Ingenium MX</title><link>https://ingeniummx.github.io/tags/raspberry-pi-pico/</link><description>Recent content in Raspberry Pi Pico on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 16 Mar 2024 18:30:00 +0200</lastBuildDate><atom:link href="https://ingeniummx.github.io/tags/raspberry-pi-pico/index.xml" rel="self" type="application/rss+xml"/><item><title>Instalar micro-ROS en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 18:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</guid><description>&lt;p&gt;&lt;strong&gt;micro-ROS&lt;/strong&gt; lleva ROS 2 a microcontroladores con recursos limitados. A continuación se describe cómo configurar el build system para la Raspberry Pi Pico utilizando el Pico SDK oficial.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="prerrequisitos"&gt;Prerrequisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Toolchain Arm (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt;), CMake y Ninja.&lt;/li&gt;
&lt;li&gt;ROS 2 Humble (o posterior) instalado en tu sistema.&lt;/li&gt;
&lt;li&gt;Repositorio &lt;code&gt;micro_ros_setup&lt;/code&gt; clonado en el workspace de ROS 2.&lt;/li&gt;
&lt;li&gt;Pico SDK inicializado (&lt;code&gt;PICO_SDK_PATH&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="configurar-el-workspace"&gt;Configurar el workspace&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source /opt/ros/humble/setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/micro-ROS/micro_ros_setup.git
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ..
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;colcon build
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source install/local_setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="crear-firmware-para-la-pico"&gt;Crear firmware para la Pico&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Importa los repositorios necesarios&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup create_firmware_ws.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;Descarga dependencias&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup configure_firmware.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;Compila&lt;/strong&gt; con opciones personalizadas (Wi-Fi deshabilitada por defecto):&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup build_firmware.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="4"&gt;
&lt;li&gt;El resultado (&lt;code&gt;firmware.uf2&lt;/code&gt;) se genera en &lt;code&gt;firmware/build&lt;/code&gt;. Cópialo a la Pico en modo BOOTSEL.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-nodo-ping"&gt;Ejemplo: nodo ping&lt;/h2&gt;
&lt;p&gt;Tras flashear, conecta la Pico por USB y ejecuta en el host:&lt;/p&gt;</description></item><item><title>Ampliar entradas digitales con I2C</title><link>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</link><pubDate>Sat, 16 Mar 2024 18:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</guid><description>&lt;p&gt;Cuando el número de GPIO de la Raspberry Pi Pico no basta, puedes &lt;strong&gt;ampliar entradas digitales&lt;/strong&gt; con expansores I2C. Estos integrados entregan 8, 16 o más pines configurables sin sacrificar recursos del microcontrolador.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="expansores-populares"&gt;Expansores populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chip&lt;/th&gt;
&lt;th&gt;Bits&lt;/th&gt;
&lt;th&gt;Voltaje&lt;/th&gt;
&lt;th&gt;Características&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MCP23017&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;1,8–5,5 V&lt;/td&gt;
&lt;td&gt;Dos bancos de 8 bits, interrupciones configurables, pull-ups internos.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PCF8575&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–5,5 V&lt;/td&gt;
&lt;td&gt;Entradas/salidas quasi-bidireccionales, ideal para lectura de botones.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCA9555&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,3–5,5 V&lt;/td&gt;
&lt;td&gt;Interrupciones separadas, compatible con 400 kHz.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SX1509&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–3,6 V&lt;/td&gt;
&lt;td&gt;PWM por pin, debounce interno y lógica de interrupciones avanzada.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="conexión-básica"&gt;Conexión básica&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Conecta SDA y SCL al bus I2C de la Pico (GPIO 4 y 5 por defecto) con &lt;strong&gt;pull-ups de 4,7 kΩ&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Alimenta el expansor con 3,3 V o el voltaje requerido.&lt;/li&gt;
&lt;li&gt;Configura las direcciones mediante pines A0-A2.&lt;/li&gt;
&lt;li&gt;Conecta pines de interrupción (INTA/INTB) a GPIO disponibles para detectar cambios sin sondeo constante.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-con-mcp23017-en-micropython"&gt;Ejemplo con MCP23017 en MicroPython&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; machine &lt;span style="color:#f92672"&gt;import&lt;/span&gt; I2C, Pin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; mcp23017 &lt;span style="color:#f92672"&gt;import&lt;/span&gt; MCP23017
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;i2c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; I2C(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, scl&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;), sda&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;), freq&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;400000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp &lt;span style="color:#f92672"&gt;=&lt;/span&gt; MCP23017(i2c, address&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0x20&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado0 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado1 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;# Procesa botones&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;En C/C++ utiliza la librería &lt;code&gt;hardware/i2c.h&lt;/code&gt; y escribe a los registros &lt;code&gt;IODIRA&lt;/code&gt;, &lt;code&gt;GPPUA&lt;/code&gt; y &lt;code&gt;GPIOA&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Programar la Pico en C++</title><link>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</link><pubDate>Sat, 16 Mar 2024 13:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</guid><description>&lt;p&gt;Programar la Raspberry Pi Pico directamente en C/C++ ofrece máximo control sobre el hardware y mejor desempeño que las capas de compatibilidad Arduino. Estos son los pasos clave para configurar el entorno oficial &lt;strong&gt;Pico SDK&lt;/strong&gt; en Windows, Linux o macOS.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="requisitos-previos"&gt;Requisitos previos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Toolchain Arm GCC&lt;/strong&gt; (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; y &lt;code&gt;newlib&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMake ≥ 3.13&lt;/strong&gt; y &lt;strong&gt;Ninja&lt;/strong&gt; o Make.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 3&lt;/strong&gt; para scripts auxiliares.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt; para clonar el SDK y submódulos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En Windows se recomienda usar &lt;strong&gt;WSL&lt;/strong&gt; o el instalador oficial que empaqueta todas las dependencias.&lt;/p&gt;</description></item><item><title>Módulos PIO en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 13:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</guid><description>&lt;p&gt;Los &lt;strong&gt;módulos PIO (Programmable I/O)&lt;/strong&gt; del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-pio"&gt;Arquitectura PIO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Máquinas de estado:&lt;/strong&gt; hasta 4 por bloque, cada una con 32 instrucciones de 16 bits.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO TX/RX:&lt;/strong&gt; buffers de 4 palabras para intercambio con la CPU o DMA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins flexibles:&lt;/strong&gt; mapeo independiente para entrada, salida y side-set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock divider:&lt;/strong&gt; ajusta la frecuencia de ejecución con resolución fraccional.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-trabajo"&gt;Flujo de trabajo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Escribe el programa PIO en ensamblador específico (&lt;code&gt;.program&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Carga el código en la instrucción memory del bloque PIO.&lt;/li&gt;
&lt;li&gt;Configura los registros de control (SM, clocks, pins).&lt;/li&gt;
&lt;li&gt;Usa la API del SDK o MicroPython para enviar/recibir datos.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplos-prácticos"&gt;Ejemplos prácticos&lt;/h2&gt;
&lt;h3 id="ws2812-neopixel"&gt;WS2812 (NeoPixel)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Genera los pulsos de 800 kHz con side-set para controlar tiras RGB.&lt;/li&gt;
&lt;li&gt;Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interfaces-vgadvi"&gt;Interfaces VGA/DVI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas.&lt;/li&gt;
&lt;li&gt;Requiere DMA para alimentar los buffers a alta velocidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="captura-de-señales"&gt;Captura de señales&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura una máquina PIO en modo &lt;code&gt;IN&lt;/code&gt; para muestrear pines a alta frecuencia.&lt;/li&gt;
&lt;li&gt;Vuelca los datos a memoria mediante DMA para análisis posterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-de-implementación"&gt;Consejos de implementación&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Planifica el ancho de palabra.&lt;/strong&gt; Ajusta &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt; y shift registers para empaquetar datos eficientemente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Utiliza DMA.&lt;/strong&gt; Mantiene alimentadas las FIFOs sin bloquear la CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Divide funciones entre máquinas.&lt;/strong&gt; Un bloque puede generar reloj y otro manejar datos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura con &lt;code&gt;pioasm&lt;/code&gt;.&lt;/strong&gt; El SDK incluye herramientas para validar el programa antes de compilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincroniza con IRQ.&lt;/strong&gt; Usa interrupciones PIO para coordinar eventos con el firmware principal.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="recursos-adicionales"&gt;Recursos adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Documentación oficial del &lt;strong&gt;RP2040 Datasheet&lt;/strong&gt; (capítulo PIO).&lt;/li&gt;
&lt;li&gt;Ejemplos del &lt;strong&gt;Pico SDK&lt;/strong&gt; (&lt;code&gt;pio/&lt;/code&gt;): UART, I²C, PWM mejorado, DVI.&lt;/li&gt;
&lt;li&gt;Librerías comunitarias como &lt;strong&gt;rp2040-pio-emulator&lt;/strong&gt; para pruebas en PC.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.&lt;/p&gt;</description></item><item><title>Raspberry Pi Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</link><pubDate>Sat, 16 Mar 2024 11:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</guid><description>&lt;p&gt;La &lt;strong&gt;Raspberry Pi Pico&lt;/strong&gt; es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="especificaciones-esenciales"&gt;Especificaciones esenciales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microcontrolador:&lt;/strong&gt; RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria:&lt;/strong&gt; 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Periféricos:&lt;/strong&gt; 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación:&lt;/strong&gt; 1,8–5,5 V, regulador buck-boost integrado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos:&lt;/strong&gt; Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="fortalezas-del-rp2040"&gt;Fortalezas del RP2040&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PIO (Programmable I/O).&lt;/strong&gt; Motores de estado que permiten implementar protocolos personalizados a nivel de hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doble núcleo.&lt;/strong&gt; Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bajo costo y disponibilidad.&lt;/strong&gt; La placa base ronda los 4 USD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad y documentación amplia.&lt;/strong&gt; SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso-recomendados"&gt;Casos de uso recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controladores de robots educativos&lt;/strong&gt; gracias a su PWM abundante y soporte MicroPython.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces personalizadas&lt;/strong&gt; (DVI, VGA, audio PDM) mediante PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT económico&lt;/strong&gt; con el modelo Pico W y su módulo Wi-Fi CYW43439.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentos de laboratorio DIY&lt;/strong&gt; como generadores de señales y analizadores lógicos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-software"&gt;Ecosistema de software&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pico SDK (C/C++).&lt;/strong&gt; Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython y CircuitPython.&lt;/strong&gt; Repl inmediato, ideal para iterar rápido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TinyUSB.&lt;/strong&gt; Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bibliotecas de terceros.&lt;/strong&gt; Drivers para pantallas, sensores y motores mantenidos por la comunidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-proyectos"&gt;Consejos para proyectos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Usa el &lt;strong&gt;SMPS integrado&lt;/strong&gt; (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA.&lt;/li&gt;
&lt;li&gt;Aprovecha el &lt;strong&gt;debug por SWD&lt;/strong&gt; expuesto en los pads debajo de la placa.&lt;/li&gt;
&lt;li&gt;Para aplicaciones críticas, añade &lt;strong&gt;flash externa de calidad&lt;/strong&gt; y watchdog habilitado.&lt;/li&gt;
&lt;li&gt;Documenta la versión del SDK en tu repositorio para reproducibilidad.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.&lt;/p&gt;</description></item></channel></rss>