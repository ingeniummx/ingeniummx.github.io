<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Microcontroladores on Ingenium MX</title><link>https://ingeniummx.github.io/tags/microcontroladores/</link><description>Recent content in Microcontroladores on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 16 Mar 2024 11:00:00 +0200</lastBuildDate><atom:link href="https://ingeniummx.github.io/tags/microcontroladores/index.xml" rel="self" type="application/rss+xml"/><item><title>Raspberry Pi Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</link><pubDate>Sat, 16 Mar 2024 11:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</guid><description>&lt;p&gt;La &lt;strong&gt;Raspberry Pi Pico&lt;/strong&gt; es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="especificaciones-esenciales"&gt;Especificaciones esenciales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microcontrolador:&lt;/strong&gt; RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria:&lt;/strong&gt; 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Periféricos:&lt;/strong&gt; 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación:&lt;/strong&gt; 1,8–5,5 V, regulador buck-boost integrado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos:&lt;/strong&gt; Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="fortalezas-del-rp2040"&gt;Fortalezas del RP2040&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PIO (Programmable I/O).&lt;/strong&gt; Motores de estado que permiten implementar protocolos personalizados a nivel de hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doble núcleo.&lt;/strong&gt; Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bajo costo y disponibilidad.&lt;/strong&gt; La placa base ronda los 4 USD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad y documentación amplia.&lt;/strong&gt; SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso-recomendados"&gt;Casos de uso recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controladores de robots educativos&lt;/strong&gt; gracias a su PWM abundante y soporte MicroPython.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces personalizadas&lt;/strong&gt; (DVI, VGA, audio PDM) mediante PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT económico&lt;/strong&gt; con el modelo Pico W y su módulo Wi-Fi CYW43439.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentos de laboratorio DIY&lt;/strong&gt; como generadores de señales y analizadores lógicos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-software"&gt;Ecosistema de software&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pico SDK (C/C++).&lt;/strong&gt; Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython y CircuitPython.&lt;/strong&gt; Repl inmediato, ideal para iterar rápido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TinyUSB.&lt;/strong&gt; Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bibliotecas de terceros.&lt;/strong&gt; Drivers para pantallas, sensores y motores mantenidos por la comunidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-proyectos"&gt;Consejos para proyectos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Usa el &lt;strong&gt;SMPS integrado&lt;/strong&gt; (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA.&lt;/li&gt;
&lt;li&gt;Aprovecha el &lt;strong&gt;debug por SWD&lt;/strong&gt; expuesto en los pads debajo de la placa.&lt;/li&gt;
&lt;li&gt;Para aplicaciones críticas, añade &lt;strong&gt;flash externa de calidad&lt;/strong&gt; y watchdog habilitado.&lt;/li&gt;
&lt;li&gt;Documenta la versión del SDK en tu repositorio para reproducibilidad.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.&lt;/p&gt;</description></item><item><title>Pull-up vs pull-down</title><link>https://ingeniummx.github.io/posts/electronica/pull-up-vs-pull-down/</link><pubDate>Sat, 16 Mar 2024 09:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/pull-up-vs-pull-down/</guid><description>&lt;p&gt;Las entradas digitales en microcontroladores, FPGAs o sensores necesitan una referencia estable de nivel lógico cuando el pulsador o dispositivo externo está abierto. Para lograrlo usamos &lt;strong&gt;resistencias pull-up y pull-down&lt;/strong&gt;. Saber cuándo elegir cada una evita lecturas erráticas y consumo innecesario.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="qué-hace-una-resistencia-pull-up"&gt;Qué hace una resistencia pull-up&lt;/h2&gt;
&lt;p&gt;Una &lt;strong&gt;pull-up&lt;/strong&gt; conecta la entrada a (V_{CC}) mediante una resistencia. Cuando el botón está abierto la entrada lee un &amp;ldquo;1&amp;rdquo; lógico; al cerrar el contacto hacia tierra, la corriente fluye a través de la resistencia y el nodo cae a &amp;ldquo;0&amp;rdquo;.&lt;/p&gt;</description></item></channel></rss>