<!doctype html><html lang=es><head><title>Microcontroladores</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="Ingenium MX"><meta name=keywords content="ingeniería,mecatrónica,robótica,electrónica,programación,maker,tutoriales"><link rel=stylesheet href=/application.f903a84a4d6cdf391a9c73c052bdad738f02d47ae2885f2dc6791d63bff5750d.css integrity="sha256-+QOoSk1s3zkanHPAUr2tc48C1HriiF8txnkdY7/1dQ0="><link rel=icon type=image/png href=/images/site/favicon_hu_f8052c7b59e526d6.png><link rel=alternate type=application/rss+xml href=https://ingeniummx.github.io/categories/microcontroladores/index.xml title="Ingenium MX"><meta property="og:title" content="Ingenium Mx – Aprende, construye, crea"><meta property="og:type" content="website"><meta property="og:description" content="Ingenium Mx – Aprende, construye, crea. Comunidad de innovación en ingeniería, tecnología, mecatrónica, robótica, electrónica, programación y ciencia."><meta property="og:image" content="/images/author/logo.png"><meta property="og:url" content="https://ingeniummx.github.io"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Ingenium MX"><meta name=twitter:description content="Ingenium Mx – Aprende, construye, crea. Un espacio dedicado a proyectos de ingeniería, ciencia, tecnología, mecatrónica, robótica, electrónica, programación."><meta name=twitter:image content="/images/author/logo2.png"><meta name=twitter:url content="https://ingeniummx.github.io/"><meta name=twitter:site content="@ingeniummx"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","url":"https:\/\/ingeniummx.github.io\/","name":"Ingenium MX","description":"","publisher":{"@type":"Organization","name":"Ingenium MX","logo":{"@type":"ImageObject","url":"https:\/\/ingeniummx.github.io\/images\/author\/logo3.png"}},"inLanguage":"es"}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2537780317928465" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-09PLHGV7MZ"></script><script>var dnt,doNotTrack=!1;if(null&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-09PLHGV7MZ")}</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","tb58j7pbqy")</script><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-categories kind-term" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/main-logo_hu_f8052c7b59e526d6.png id=logo alt=Logo>
Ingenium MX</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Inicio</a></li><li class=nav-item><a class=nav-link href=/#about>Acerca de</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>Posts</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Blog</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme"></a></div></li></ul></div></div><img src=/images/site/main-logo_hu_f8052c7b59e526d6.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_hu_f8052c7b59e526d6.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Búsqueda data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/categories data-filter=all>Categorías</a></li><div class="subtree taxonomy-terms"><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/alta-velocidad/ data-taxonomy-term=alta-velocidad><span class=taxonomy-label>Alta Velocidad</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/anal%C3%B3gico/ data-taxonomy-term=anal%C3%B3gico><span class=taxonomy-label>Analógico</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/automatizaci%C3%B3n-industrial/ data-taxonomy-term=automatizaci%C3%B3n-industrial><span class=taxonomy-label>Automatización Industrial</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/b%C3%A1sico/ data-taxonomy-term=b%C3%A1sico><span class=taxonomy-label>Básico</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/comunicaciones/ data-taxonomy-term=comunicaciones><span class=taxonomy-label>Comunicaciones</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/control-de-movimiento/ data-taxonomy-term=control-de-movimiento><span class=taxonomy-label>Control De Movimiento</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/desarrollo/ data-taxonomy-term=desarrollo><span class=taxonomy-label>Desarrollo</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/dise%C3%B1o-digital/ data-taxonomy-term=dise%C3%B1o-digital><span class=taxonomy-label>Diseño Digital</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/dise%C3%B1o-electr%C3%B3nico/ data-taxonomy-term=dise%C3%B1o-electr%C3%B3nico><span class=taxonomy-label>Diseño Electrónico</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/electr%C3%B3nica/ data-taxonomy-term=electr%C3%B3nica><span class=taxonomy-label>Electrónica</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/energ%C3%ADa/ data-taxonomy-term=energ%C3%ADa><span class=taxonomy-label>Energía</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/hardware/ data-taxonomy-term=hardware><span class=taxonomy-label>Hardware</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/hardware-digital/ data-taxonomy-term=hardware-digital><span class=taxonomy-label>Hardware Digital</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/inteligencia-artificial/ data-taxonomy-term=inteligencia-artificial><span class=taxonomy-label>Inteligencia Artificial</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/iot/ data-taxonomy-term=iot><span class=taxonomy-label>IoT</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/linux/ data-taxonomy-term=linux><span class=taxonomy-label>Linux</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/mecatr%C3%B3nica/ data-taxonomy-term=mecatr%C3%B3nica><span class=taxonomy-label>Mecatrónica</span></a></li><li><a class="taxonomy-term active" href=https://ingeniummx.github.io/categories/microcontroladores/ data-taxonomy-term=microcontroladores><span class=taxonomy-label>Microcontroladores</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/proyectos/ data-taxonomy-term=proyectos><span class=taxonomy-label>Proyectos</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/redes-industriales/ data-taxonomy-term=redes-industriales><span class=taxonomy-label>Redes Industriales</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/rob%C3%B3tica/ data-taxonomy-term=rob%C3%B3tica><span class=taxonomy-label>Robótica</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/sensores/ data-taxonomy-term=sensores><span class=taxonomy-label>Sensores</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/software/ data-taxonomy-term=software><span class=taxonomy-label>Software</span></a></li><li><a class=taxonomy-term href=https://ingeniummx.github.io/categories/tutoriales/ data-taxonomy-term=tutoriales><span class=taxonomy-label>Tutoriales</span></a></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/ class=post-card-link><h5 class=card-title>Cómo elegir el módulo ESP32 ideal para tu PCB</h5><p class="card-text post-summary">Cómo elegir el módulo ESP32 ideal para tu PCB La familia ESP32 es estándar en IoT por costo, Wi-Fi/BLE y ecosistema. Al pasar de prototipo a producto, la elección del módulo impacta RF, consumo, certificación y BOM. Esta guía resume criterios técnicos, regulatorios y logísticos para seleccionar con confianza.
1) Define requisitos del producto Energía y consumo. ¿Batería o línea? Filtra por deep sleep (≈5 µA en C3 hasta >20 µA en S3) y por picos de TX (500–700 mA). Conectividad. Además de Wi-Fi 2.4 GHz, hay BLE 5.x (C3/S3), 802.15.4 para Thread/Matter (C6), e incluso variantes sin Wi-Fi (H2). Elige primero la familia por protocolo. Memoria y periféricos. TLS pesado, UI, voz/visión → PSRAM + más flash (p.ej., WROVER, S3 8–16 MB). Sensores simples → 2–4 MB. Entorno. Rango de temperatura, blindaje metálico y robustez EMI (p.ej., WROOM-32E/UE). Verifica versiones industriales. 2) Elige la familia ESP32 Familia CPU Radios Ventajas Casos típicos ESP32 (WROOM/WROVER) Xtensa LX6 Wi-Fi b/g/n, BT Classic + LE Ecosistema maduro, opciones con PSRAM Gateways, audio, TFT ESP32-S2/S3 Xtensa (S3 con SIMD) Wi-Fi (S3: + BLE) USB OTG, aceleraciones para IA HID, cámaras/LCD, edge-AI ESP32-C2/C3/C6 RISC-V C3: Wi-Fi + BLE; C6: + 802.15.4 Bajo consumo, Matter/Thread Batería, domótica ESP32-H2 RISC-V BLE + 802.15.4 Ultra bajo consumo, sin Wi-Fi Zigbee/Thread con pila Primero familia por protocolo/consumo; luego la variante.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/esp32/ class="btn btn-sm btn-info">ESP32</a></li><li class=rounded><a href=/tags/hardware/ class="btn btn-sm btn-info">Hardware</a></li><li class=rounded><a href=/tags/dise%C3%B1o-de-pcb/ class="btn btn-sm btn-info">Diseño de PCB</a></li><li class=rounded><a href=/tags/iot/ class="btn btn-sm btn-info">IoT</a></li></ul></div></div><div class=card-footer><span class=float-start>miércoles, 5 de junio de 2024
| 3 minutos </span><a href=/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/instalar-micro-ros-en-la-pico/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/instalar-micro-ros-en-la-pico/ class=post-card-link><h5 class=card-title>Instalar micro-ROS en la Pico</h5><p class="card-text post-summary">micro-ROS lleva ROS 2 a microcontroladores con recursos limitados. A continuación se describe cómo configurar el build system para la Raspberry Pi Pico utilizando el Pico SDK oficial.
Prerrequisitos Toolchain Arm (arm-none-eabi-gcc), CMake y Ninja. ROS 2 Humble (o posterior) instalado en tu sistema. Repositorio micro_ros_setup clonado en el workspace de ROS 2. Pico SDK inicializado (PICO_SDK_PATH). Configurar el workspace source /opt/ros/humble/setup.bash mkdir -p ~/micro_ros_ws/src cd ~/micro_ros_ws/src git clone https://github.com/micro-ROS/micro_ros_setup.git cd .. colcon build source install/local_setup.bash Crear firmware para la Pico Importa los repositorios necesarios: ros2 run micro_ros_setup create_firmware_ws.sh freertos raspberripi_pico Descarga dependencias: ros2 run micro_ros_setup configure_firmware.sh freertos raspberripi_pico Compila con opciones personalizadas (Wi-Fi deshabilitada por defecto): ros2 run micro_ros_setup build_firmware.sh El resultado (firmware.uf2) se genera en firmware/build. Cópialo a la Pico en modo BOOTSEL. Ejemplo: nodo ping Tras flashear, conecta la Pico por USB y ejecuta en el host:</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/micro-ros/ class="btn btn-sm btn-info">micro-ROS</a></li><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/ros-2/ class="btn btn-sm btn-info">ROS 2</a></li><li class=rounded><a href=/tags/embedded/ class="btn btn-sm btn-info">Embedded</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/instalar-micro-ros-en-la-pico/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/ class=post-card-link><h5 class=card-title>Ampliar entradas digitales con I2C</h5><p class="card-text post-summary">Cuando el número de GPIO de la Raspberry Pi Pico no basta, puedes ampliar entradas digitales con expansores I2C. Estos integrados entregan 8, 16 o más pines configurables sin sacrificar recursos del microcontrolador.
Expansores populares Chip Bits Voltaje Características MCP23017 16 1,8–5,5 V Dos bancos de 8 bits, interrupciones configurables, pull-ups internos. PCF8575 16 2,5–5,5 V Entradas/salidas quasi-bidireccionales, ideal para lectura de botones. TCA9555 16 2,3–5,5 V Interrupciones separadas, compatible con 400 kHz. SX1509 16 2,5–3,6 V PWM por pin, debounce interno y lógica de interrupciones avanzada. Conexión básica Conecta SDA y SCL al bus I2C de la Pico (GPIO 4 y 5 por defecto) con pull-ups de 4,7 kΩ. Alimenta el expansor con 3,3 V o el voltaje requerido. Configura las direcciones mediante pines A0-A2. Conecta pines de interrupción (INTA/INTB) a GPIO disponibles para detectar cambios sin sondeo constante. Ejemplo con MCP23017 en MicroPython from machine import I2C, Pin from mcp23017 import MCP23017 i2c = I2C(0, scl=Pin(5), sda=Pin(4), freq=400000) exp = MCP23017(i2c, address=0x20) exp.setup(0, MCP23017.IN, pullup=True) exp.setup(1, MCP23017.IN, pullup=True) while True: estado0 = exp.input(0) estado1 = exp.input(1) # Procesa botones En C/C++ utiliza la librería hardware/i2c.h y escribe a los registros IODIRA, GPPUA y GPIOA.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/i2c/ class="btn btn-sm btn-info">I2C</a></li><li class=rounded><a href=/tags/expansores-gpio/ class="btn btn-sm btn-info">Expansores GPIO</a></li><li class=rounded><a href=/tags/hardware-modular/ class="btn btn-sm btn-info">Hardware modular</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class=post-card-link><h5 class=card-title>Programar la Pico en C++</h5><p class="card-text post-summary">Programar la Raspberry Pi Pico directamente en C/C++ ofrece máximo control sobre el hardware y mejor desempeño que las capas de compatibilidad Arduino. Estos son los pasos clave para configurar el entorno oficial Pico SDK en Windows, Linux o macOS.
Requisitos previos Toolchain Arm GCC (arm-none-eabi-gcc y newlib). CMake ≥ 3.13 y Ninja o Make. Python 3 para scripts auxiliares. Git para clonar el SDK y submódulos. En Windows se recomienda usar WSL o el instalador oficial que empaqueta todas las dependencias.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/c++/ class="btn btn-sm btn-info">C++</a></li><li class=rounded><a href=/tags/pico-sdk/ class="btn btn-sm btn-info">Pico SDK</a></li><li class=rounded><a href=/tags/herramientas-de-desarrollo/ class="btn btn-sm btn-info">Herramientas de desarrollo</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class=post-card-link><h5 class=card-title>Módulos PIO en la Pico</h5><p class="card-text post-summary">Los módulos PIO (Programmable I/O) del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.
Arquitectura PIO Máquinas de estado: hasta 4 por bloque, cada una con 32 instrucciones de 16 bits. FIFO TX/RX: buffers de 4 palabras para intercambio con la CPU o DMA. Pins flexibles: mapeo independiente para entrada, salida y side-set. Clock divider: ajusta la frecuencia de ejecución con resolución fraccional. Flujo de trabajo Escribe el programa PIO en ensamblador específico (.program). Carga el código en la instrucción memory del bloque PIO. Configura los registros de control (SM, clocks, pins). Usa la API del SDK o MicroPython para enviar/recibir datos. Ejemplos prácticos WS2812 (NeoPixel) Genera los pulsos de 800 kHz con side-set para controlar tiras RGB. Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización. Interfaces VGA/DVI Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas. Requiere DMA para alimentar los buffers a alta velocidad. Captura de señales Configura una máquina PIO en modo IN para muestrear pines a alta frecuencia. Vuelca los datos a memoria mediante DMA para análisis posterior. Consejos de implementación Planifica el ancho de palabra. Ajusta push/pull y shift registers para empaquetar datos eficientemente. Utiliza DMA. Mantiene alimentadas las FIFOs sin bloquear la CPU. Divide funciones entre máquinas. Un bloque puede generar reloj y otro manejar datos. Depura con pioasm. El SDK incluye herramientas para validar el programa antes de compilar. Sincroniza con IRQ. Usa interrupciones PIO para coordinar eventos con el firmware principal. Recursos adicionales Documentación oficial del RP2040 Datasheet (capítulo PIO). Ejemplos del Pico SDK (pio/): UART, I²C, PWM mejorado, DVI. Librerías comunitarias como rp2040-pio-emulator para pruebas en PC. Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/pio/ class="btn btn-sm btn-info">PIO</a></li><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/rp2040/ class="btn btn-sm btn-info">RP2040</a></li><li class=rounded><a href=/tags/protocolos-personalizados/ class="btn btn-sm btn-info">Protocolos personalizados</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class=post-card-link><h5 class=card-title>Elegir la ESP32 adecuada</h5><p class="card-text post-summary">La familia ESP32 de Espressif incluye docenas de variantes con diferentes radios, memoria y encapsulados. Escoger el módulo correcto evita limitaciones de memoria, consumo excesivo o falta de certificaciones inalámbricas.
Criterios de selección Conectividad inalámbrica. ¿Necesitas Wi-Fi 2,4 GHz, Bluetooth LE, Classic o incluso 802.15.4? Memoria y almacenamiento. Flash integrada (4–16 MB), PSRAM opcional para buffers gráficos o voz. GPIO disponibles. Algunos módulos comparten pines con la antena o el cristal, reduciendo los I/O libres. Certificaciones. Para productos finales busca módulos con FCC/CE y antena integrada. Consumo energético. Evalúa modos de suspensión, corriente en deep sleep y voltaje operativo. Variantes populares Módulo CPU RAM/Flash Radios Características clave ESP32-WROOM-32 Xtensa LX6 dual a 240 MHz 520 KB + 4 MB flash Wi-Fi + BT Classic/LE DevkitC, amplio soporte, antena PCB. ESP32-WROVER Xtensa LX6 dual 520 KB + 4 MB flash + 8 MB PSRAM Wi-Fi + BT Ideal para gráficos, cámaras o SSL pesado. ESP32-C3 RISC-V single 160 MHz 400 KB + 4 MB flash Wi-Fi + BT LE 5 Bajo consumo, pin-to-pin con ESP8266. ESP32-S3 Xtensa LX7 dual 240 MHz 512 KB + 8 MB flash/PSRAM Wi-Fi + BT LE 5 Vector instructions para IA, USB OTG. ESP32-C6 RISC-V single 160 MHz 512 KB + 4 MB flash Wi-Fi 6 + BT LE 5 + 802.15.4 Thread/Matter listo, eficiente. Devkits recomendados ESP32-DevKitC: Referencia básica para WROOM. Incluye convertidor USB-UART y fácil acceso a pines. ESP32-S3-DevKitC-1: Para proyectos de visión gracias a USB nativo y soporte para cámaras. ESP32-C3-DevKitM-1: Ideal para wearables y sensores de baja potencia. LilyGO T-Display / T-Embed: Añaden pantalla IPS, ranura microSD y batería LiPo integrada. Consejos prácticos Define primero la pila de software. ESP-IDF, Arduino Core, MicroPython o circuitos con Matter pueden requerir memoria adicional. Revisa el pinout oficial. Algunos GPIO no toleran 5 V o están reservados para arranque (GPIO0, GPIO2, GPIO15). Planea la antena. Respeta el keep-out de la PCB o el conector U.FL para no degradar la potencia. Aprovecha los modos de bajo consumo. Configura RTC, ULP y wake-up por GPIO o temporizador para aplicaciones alimentadas por batería. Certifica tu producto. Usa módulos pre-certificados y documenta las pruebas de radiofrecuencia. Con esta matriz podrás elegir el módulo ESP32 que mejor se ajuste a tu presupuesto, consumo y requisitos de conectividad.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/esp32/ class="btn btn-sm btn-info">ESP32</a></li><li class=rounded><a href=/tags/iot/ class="btn btn-sm btn-info">IoT</a></li><li class=rounded><a href=/tags/wi-fi/ class="btn btn-sm btn-info">Wi-Fi</a></li><li class=rounded><a href=/tags/bluetooth/ class="btn btn-sm btn-info">Bluetooth</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/raspberry-pi-pico/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/raspberry-pi-pico/ class=post-card-link><h5 class=card-title>Raspberry Pi Pico</h5><p class="card-text post-summary">La Raspberry Pi Pico es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.
Especificaciones esenciales Microcontrolador: RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz). Memoria: 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI. Periféricos: 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO. Alimentación: 1,8–5,5 V, regulador buck-boost integrado. Formatos: Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles. Fortalezas del RP2040 PIO (Programmable I/O). Motores de estado que permiten implementar protocolos personalizados a nivel de hardware. Doble núcleo. Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel. Bajo costo y disponibilidad. La placa base ronda los 4 USD. Comunidad y documentación amplia. SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales. Casos de uso recomendados Controladores de robots educativos gracias a su PWM abundante y soporte MicroPython. Interfaces personalizadas (DVI, VGA, audio PDM) mediante PIO. IoT económico con el modelo Pico W y su módulo Wi-Fi CYW43439. Instrumentos de laboratorio DIY como generadores de señales y analizadores lógicos. Ecosistema de software Pico SDK (C/C++). Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales. MicroPython y CircuitPython. Repl inmediato, ideal para iterar rápido. TinyUSB. Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar. Bibliotecas de terceros. Drivers para pantallas, sensores y motores mantenidos por la comunidad. Consejos para proyectos Usa el SMPS integrado (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA. Aprovecha el debug por SWD expuesto en los pads debajo de la placa. Para aplicaciones críticas, añade flash externa de calidad y watchdog habilitado. Documenta la versión del SDK en tu repositorio para reproducibilidad. Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/rp2040/ class="btn btn-sm btn-info">RP2040</a></li><li class=rounded><a href=/tags/microcontroladores/ class="btn btn-sm btn-info">Microcontroladores</a></li><li class=rounded><a href=/tags/prototipado/ class="btn btn-sm btn-info">Prototipado</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/raspberry-pi-pico/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div></div><div class=paginator></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navegación</h5><ul><li class=nav-item><a class=smooth-scroll href=https://ingeniummx.github.io/#about>Acerca de</a></li><li class=nav-item><a class=smooth-scroll href=https://ingeniummx.github.io/#recent-posts>Posts</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contacto</h5><ul><li><a href=mailto:ingenium.mex01@gmail.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ingenium.mex01@gmail.com</span></a></li><li><a href=https://github.com/ingeniummx target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>ingeniummx</span></a></li><li><a href=https://www.linkedin.com/in/ingenium-mx target=_blank rel=noopener><span><i class="fab fa-linkedin"></i></span> <span>Ingenium Mx</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu_b3360284c55cf72d.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2025 Ingenium Mx. Todos los derechos reservados.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Funcionando con
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.8db5b0dfda15f470a64b8c7de3b5be444659ae73f75bc4ede628de3ad8bd54a9.js integrity="sha256-jbWw39oV9HCmS4x947W+REZZrnP3W8Tt5ijeOti9VKk=" defer></script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=ingeniummx data-description="Support me on Buy me a coffee!" data-message="Buy me a coffee!" data-color=#FFDD00 data-position=Right data-x_margin=10 data-y_margin=18></script></body></html>