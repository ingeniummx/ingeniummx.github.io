[{"categories":["Electr√≥nica","IoT","Redes industriales"],"contents":"El protocolo MQTT (Message Queuing Telemetry Transport) se ha convertido en el idioma com√∫n de los proyectos IoT, tanto dom√©sticos como industriales. Es ligero, funciona bien con enlaces inestables y permite que sensores, microcontroladores, dashboards y servicios en la nube intercambien datos sin enredarse en sockets manuales. Su modelo publish/subscribe gira alrededor de un broker que recibe, filtra y entrega mensajes, de los clientes que publican o se suscriben, y de los temas (topics) que organizan la informaci√≥n con rutas jer√°rquicas como ingenium/sala/temperatura.\nArquitectura publish/subscribe (sin acoplamientos duros) A diferencia de HTTP, el emisor no conoce al receptor. El broker se encarga de recibir lo que publica un cliente y reenviarlo a todos los suscritos al mismo topic.\nPLACEHOLDER IMG:\u0026nbsp; \"mqtt-topology.png\" ‚Äî Diagrama publish/subscribe con nodos, broker central y topics Topolog√≠a t√≠pica: sensores publican, dashboards y actuadores se suscriben.\nGracias a esa capa intermedia es posible escalar con facilidad, sumar clientes sin tocar el c√≥digo de los dem√°s y separar responsabilidades; un ESP32 puede limitarse a enviar datos mientras que la visualizaci√≥n corre en otro entorno. Tambi√©n facilita la integraci√≥n de sistemas heterog√©neos, desde PLC y Raspberry Pi hasta servicios en la nube, bajo un mismo esquema de temas.\nC√≥mo fluye un mensaje MQTT El flujo t√≠pico empieza con un cliente que publica en un tema espec√≠fico. El broker recibe la carga, la etiqueta con el nombre del topic correspondiente y la reenv√≠a a todos los clientes suscritos. Cada suscriptor decide qu√© hacer con el payload: actualizar una gr√°fica, encender un relevador o guardar el dato en una base de datos. Este ciclo puede repetirse en milisegundos y acepta metadatos como la calidad de servicio (QoS) y la retenci√≥n de mensajes.\nNiveles de QoS (Quality of Service) MQTT define tres niveles de QoS para balancear fiabilidad y consumo de red. El nivel 0 entrega un mensaje una sola vez sin confirmaci√≥n, por lo que resulta ideal en telemetr√≠a frecuente donde perder un paquete no afecta. El nivel 1 solicita confirmaciones al destinatario y reenv√≠a si no las recibe, lo que implica dise√±ar clientes idempotentes para ignorar duplicados. El nivel 2 a√±ade un apret√≥n de manos en cuatro pasos que garantiza una entrega √∫nica a costa de mayor latencia, reservado para escenarios cr√≠ticos.\nRetenci√≥n, sesiones y last will El broker puede almacenar el √∫ltimo mensaje de un tema mediante la funci√≥n retained message, que resulta √∫til para estados como ingenium/lab/puerta. Tambi√©n admite la persistencia de sesi√≥n para que los clientes recuperen sus suscripciones despu√©s de una reconexi√≥n. Por √∫ltimo, ofrece el mecanismo Last Will \u0026amp; Testament (LWT) que se publica autom√°ticamente si un cliente se desconecta de forma inesperada y as√≠ se avisa al resto del sistema.\nMosquitto: el broker libre m√°s popular Eclipse Mosquitto es un broker MQTT open source, ligero y con paquetes listos para Linux, Windows y contenedores Docker. Es una elecci√≥n ideal para instalarlo en una Raspberry Pi, en un servidor casero o incluso en ambientes de producci√≥n. En sistemas Debian o Ubuntu basta con actualizar los repositorios, instalar los paquetes mosquitto y mosquitto-clients, y habilitar el servicio para que el broker comience a escuchar en tcp://localhost:1883. Las herramientas que acompa√±an al paquete permiten realizar pruebas inmediatas al suscribirse y publicar mensajes en un mismo equipo.\nSeguridad b√°sica (no lo dejes abierto) Cuando Mosquitto se expone fuera de la red local conviene activar autenticaci√≥n con usuarios y contrase√±as generadas con mosquitto_passwd, habilitar TLS con certificados y configurar listas de control de acceso que limiten los temas disponibles para cada cliente. Estas capas evitan que un broker abierto se convierta en una puerta de entrada a la infraestructura.\nPLACEHOLDER IMG:\u0026nbsp; \"mosquitto-security-layers.png\" ‚Äî Esquema con autenticaci√≥n, TLS y ACLs Capas m√≠nimas cuando el broker sale a Internet.\nBuenas pr√°cticas para tus proyectos IoT Conviene definir desde el inicio una jerarqu√≠a de temas clara, por ejemplo ingenium/\u0026lt;√°rea\u0026gt;/\u0026lt;dispositivo\u0026gt;/\u0026lt;sensor\u0026gt;, y documentar el formato del payload para mantener la coherencia entre clientes. Los mensajes retenidos resultan valiosos al reportar estados cr√≠ticos, mientras que el nivel de QoS 1 asegura que los comandos importantes no se pierdan. El broker ofrece m√©tricas que pueden integrarse con herramientas como Prometheus o Telegraf, y se puede automatizar su despliegue mediante Docker o servicios de systemd para garantizar que el sistema regrese a la vida despu√©s de un corte el√©ctrico.\nConclusi√≥n MQTT es la pieza que conecta sensores, actuadores y servicios sin que dependan unos de otros. Con un broker como Mosquitto puedes empezar r√°pido, crecer a decenas de dispositivos y reforzar la seguridad sin cambiar tu c√≥digo base. Ideal para el proyecto Ingenium MX cuando necesites una columna vertebral de comunicaciones ligera y confiable.\n","date":"September 18, 2025","hero":"/images/default-hero.jpg","permalink":"https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/","summary":"\u003cp\u003eEl \u003cstrong\u003eprotocolo MQTT (Message Queuing Telemetry Transport)\u003c/strong\u003e se ha convertido en el \u003cem\u003eidioma com√∫n\u003c/em\u003e de los proyectos \u003cstrong\u003eIoT\u003c/strong\u003e, tanto dom√©sticos como industriales. Es \u003cstrong\u003eligero\u003c/strong\u003e, funciona bien con enlaces inestables y permite que sensores, microcontroladores, dashboards y servicios en la nube intercambien datos sin enredarse en sockets manuales. Su modelo \u003cstrong\u003epublish/subscribe\u003c/strong\u003e gira alrededor de un broker que recibe, filtra y entrega mensajes, de los clientes que publican o se suscriben, y de los temas (\u003cem\u003etopics\u003c/em\u003e) que organizan la informaci√≥n con rutas jer√°rquicas como \u003ccode\u003eingenium/sala/temperatura\u003c/code\u003e.\u003c/p\u003e","tags":["MQTT","IoT","Protocolos de comunicaci√≥n","Mosquitto","Electr√≥nica conectada"],"title":"¬øQu√© es MQTT y por qu√© se usa tanto en IoT?"},{"categories":["Electr√≥nica","Proyectos"],"contents":"Un puente H es un circuito que permite invertir el sentido de giro de un motor de corriente directa (DC) al cambiar la polaridad de alimentaci√≥n entre sus terminales. Se utiliza en aplicaciones donde es necesario controlar el movimiento en ambos sentidos, como en rob√≥tica o mecanismos reversibles.\nEn este proyecto vamos a construir un puente H sencillo utilizando un m√≥dulo de 2 relevadores de 5 V, muy com√∫n en kits de Arduino, para controlar un motor DC de 12 V.\n¬øQu√© es un m√≥dulo de dos relevadores? Un m√≥dulo de relevadores es una tarjeta con uno o m√°s relevadores listos para ser controlados por un microcontrolador.\nPor ejemplo, un m√≥dulo de 2 canales funciona con nivel l√≥gico bajo (LOW level trigger) a 5 V, cada canal consume unos 15‚Äì20 mA de corriente de control y puede conmutar cargas de hasta AC 250 V 10 A o DC 30 V 10 A.\nEsto lo hace ideal para controlar peque√±os motores, l√°mparas o cargas que requieren mayor corriente que la que un Arduino puede manejar directamente.\nMateriales necesarios 1 √ó Motor DC de 12 V 1 √ó M√≥dulo de 2 relevadores de 5 V 1 √ó Fuente de 12 V para el motor 1 √ó Arduino (o cualquier microcontrolador compatible) Cables de conexi√≥n Protoboard (opcional) ¬øC√≥mo funciona el cambio de direcci√≥n? Para invertir el giro del motor necesitamos cambiar la polaridad de alimentaci√≥n.\nEsto se logra cruzando las conexiones a trav√©s de los contactos NO (Normalmente Abierto) y NC (Normalmente Cerrado) de cada relevador.\nCuando uno de los relevadores conmuta, invierte la polaridad aplicada al motor y con ello el sentido de giro.\nConexiones En el siguiente diagrama se muestra c√≥mo se conecta el motor, la fuente de 12 V, el m√≥dulo de relevadores y el Arduino:\nLos comunes (C) de los relevadores van conectados a los dos terminales del motor. Los contactos NO y NC se cruzan entre s√≠ para que un lado del motor reciba +12 V y el otro GND (seg√∫n cu√°l relevador se active). El m√≥dulo de relevadores se conecta al Arduino: IN1 ‚Üí pin digital (ej. D7) IN2 ‚Üí pin digital (ej. D8) VCC ‚Üí 5 V GND ‚Üí GND üîÑ Estados de operaci√≥n El puente H hecho con relevadores tiene cuatro combinaciones posibles seg√∫n la activaci√≥n de los dos relevadores (IN1 e IN2):\nIN1 IN2 Estado del motor Explicaci√≥n 0 0 Apagado Ambos relevadores inactivos ‚Üí motor sin tensi√≥n. 1 0 Gira en un sentido Un relevador invierte la polaridad, aplicando +12 V en un borne y GND en el otro. 0 1 Gira en el otro sentido Se invierte la polaridad al contrario. 1 1 Apagado (frenado) Ambos relevadores activos ‚Üí los dos terminales del motor quedan al mismo potencial (+12 V o GND) y el motor se frena r√°pidamente. üìå Nota: estos m√≥dulos suelen ser active LOW, lo que significa que:\nINx = 0 ‚Üí relevador activado INx = 1 ‚Üí relevador desactivado üìú C√≥digo de ejemplo (Arduino) int IN1 = 7; int IN2 = 8; void setup() { pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT); } // Gira un sentido 2s, luego al otro void loop() { // Giro hacia adelante digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH); delay(2000); // Giro hacia atr√°s digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); delay(2000); // Motor apagado (frenado) digitalWrite(IN1, LOW); digitalWrite(IN2, LOW); delay(2000); } ","date":"September 16, 2025","hero":"/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/images/puente-h-relevadores-cover.jpg","permalink":"https://ingeniummx.github.io/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/","summary":"\u003cp\u003eUn \u003cstrong\u003epuente H\u003c/strong\u003e es un circuito que permite invertir el sentido de giro de un motor de corriente directa (DC) al cambiar la polaridad de alimentaci√≥n entre sus terminales. Se utiliza en aplicaciones donde es necesario controlar el movimiento en ambos sentidos, como en rob√≥tica o mecanismos reversibles.\u003c/p\u003e\n\u003cp\u003eEn este proyecto vamos a construir un puente H sencillo utilizando un \u003cstrong\u003em√≥dulo de 2 relevadores de 5 V\u003c/strong\u003e, muy com√∫n en kits de Arduino, para controlar un motor DC de 12 V.\u003c/p\u003e","tags":["Puente H","Arduino","Relevadores","Electr√≥nica b√°sica","Control de motores"],"title":"Puente H con relevadores: controla un motor DC con Arduino"},{"categories":["Linux","Desarrollo","Tutoriales"],"contents":"El Subsistema de Windows para Linux (WSL2) permite correr distribuciones de Linux dentro de Windows 11, sin necesidad de crear una m√°quina virtual con VirtualBox ni instalar dual-boot.\nEn este tutorial instalaremos Ubuntu 24.04 (Noble Numbat), configuraremos aplicaciones esenciales como git, gedit, y prepararemos el entorno para trabajar con Visual Studio Code.\n1. WSL2 en Windows 11 Abre PowerShell como administrador y ejecuta:\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart Reinicia el equipo y verifica que WSL2 est√° activo:\nwsl --status 2. Instalar Ubuntu 24.04 LTS Instala Ubuntu 24.04: wsl --install -d Ubuntu-24.04 Reinicia y busca Ubuntu 24.04 LTS desde el men√∫ inicio. La primera vez que se abre, te pedir√° crear un usuario y contrase√±a Linux, pon algo simple ya que cada que corras un comando sudo te pedir√° la contrase√±a. 3. Configuraci√≥n inicial de Ubuntu 3.1 Actualizar paquetes Siempre lo primero que debes hacer en un Linux reci√©n instalado es actualizar la lista de paquetes y aplicar actualizaciones.\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Esto descargar√° las √∫ltimas versiones y dejar√° tu sistema al d√≠a.\n3.2 Configurar locales UTF-8 Ubuntu necesita estar configurado en un locale UTF-8 para que programas como Python, Git o ROS manejen bien los caracteres especiales.\nsudo apt install -y locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 Comprueba que se aplic√≥ correctamente:\nlocale Debe mostrar en_US.UTF-8.\n3.3 Instalar programas esenciales sudo apt install -y git curl wget build-essential cmake gedit nano vim htop unzip terminator 4. Windows Terminal (recomendado) Instala Windows Terminal desde la Microsoft Store.\nVentajas:\nVarias pesta√±as y splits. Personalizaci√≥n (temas, colores, atajos). Integra PowerShell, Ubuntu, CMD en una sola app. Aunque puedes usar terminator, Windows Terminal es m√°s ligero y pr√°ctico para el d√≠a a d√≠a.\n5. Visual Studio Code con WSL 5.1 Instalar VS Code Descarga desde code.visualstudio.com e inst√°lalo en Windows.\n5.2 Instalar extensi√≥n Remote - WSL Abre VS Code ‚Üí pesta√±a Extensions. Busca WSL (Microsoft) con el √≠cono del ping√ºino üêß. Haz clic en instalar. 5.3 Conectar VS Code con Ubuntu Da clic en el icono verde \u0026gt;\u0026lt; en la esquina inferior izquierda y despu√©s en Connect to WSL y listo\n6. Buenas pr√°cticas en WSL Mant√©n tus proyectos en el sistema de archivos de Linux:\nActualiza con frecuencia:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Usa explorer.exe . desde Ubuntu para abrir la carpeta actual en el Explorador de Windows. (Aseg√∫rese de agregar el punto al final del comando para abrir el directorio actual.)\nDocumentaci√≥n https://learn.microsoft.com/es-mx/windows/wsl/\n","date":"September 15, 2025","hero":"/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/images/wsl-ubuntu-vscode-cover.jpg","permalink":"https://ingeniummx.github.io/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/","summary":"\u003cp\u003eEl \u003cstrong\u003eSubsistema de Windows para Linux (WSL2)\u003c/strong\u003e permite correr distribuciones de Linux dentro de Windows 11, sin necesidad de crear una m√°quina virtual con VirtualBox ni instalar dual-boot.\u003cbr\u003e\nEn este tutorial instalaremos \u003cstrong\u003eUbuntu 24.04 (Noble Numbat)\u003c/strong\u003e, configuraremos aplicaciones esenciales como \u003ccode\u003egit\u003c/code\u003e, \u003ccode\u003egedit\u003c/code\u003e, y prepararemos el entorno para trabajar con \u003cstrong\u003eVisual Studio Code\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"1-wsl2-en-windows-11\"\u003e1. WSL2 en Windows 11\u003c/h2\u003e\n\u003cp\u003eAbre \u003cstrong\u003ePowerShell como administrador\u003c/strong\u003e y ejecuta:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edism.exe /online /enable-feature /featurename\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003eMicrosoft-Windows-Subsystem-Linux /all /norestart\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edism.exe /online /enable-feature /featurename\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003eVirtualMachinePlatform /all /norestart\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eReinicia el equipo y verifica que WSL2 est√° activo:\u003c/p\u003e","tags":["WSL2","Ubuntu 24.04","Windows 11","VS Code","Linux","Linux en Windows"],"title":"C√≥mo instalar Ubuntu 24.04 en Windows 11 con WSL2 paso a paso"},{"categories":["Electr√≥nica","B√°sico"],"contents":"Los pulsadores, switches y rel√©s est√°n en todos lados.\nCuando los conectamos a un microcontrolador (PIC, ESP32, Arduino, etc.) esperamos un cambio de estado limpio por cada pulsaci√≥n. En la pr√°ctica no ocurre as√≠: los contactos mec√°nicos rebotan durante unos milisegundos y generan varias transiciones antes de estabilizarse. A esto se le llama rebote de contacto (contact bounce).\nPLACEHOLDER IMG:\u0026nbsp; \"button-ideal-vs-bounce.png\" ‚Äî Se√±al ideal vs con rebote Ideal vs. real: sin rebote (arriba) vs. con rebote (abajo)\nEn aplicaciones lentas (encender una l√°mpara) el rebote pasa desapercibido.\nEn sistemas digitales (contadores, men√∫s, teclados) puede convertirse en pulsaciones falsas.\n¬øPor qu√© rebotan los contactos? Por masa, elasticidad y vibraci√≥n de las piezas met√°licas. Al presionar o soltar, los contactos no se quedan quietos al primer intento: golpean y ‚Äútiemblan‚Äù durante 1‚Äì20 ms (depende de tipo/calidad, desgaste, humedad, temperatura).\nPull-up vs Pull-down (y d√≥nde aparece el rebote) Hay dos formas comunes de cablear un bot√≥n:\nPull-up: el pin est√° en 1 por defecto (resistencia a Vcc). Al presionar, cae a 0.\nPLACEHOLDER IMG:\u0026nbsp; \"button-pullup-bounce.png\" ‚Äî Esquema + forma de onda (alto‚Üíbajo con rebote) Pull-up: rebote al ir de alto a bajo\nPull-down: el pin est√° en 0 por defecto (resistencia a GND). Al presionar, sube a 1.\nPLACEHOLDER IMG:\u0026nbsp; \"button-pulldown-bounce.png\" ‚Äî Esquema + forma de onda (bajo‚Üíalto con rebote) Pull-down: rebote al ir de bajo a alto\nC√≥mo eliminar el rebote (antirrebote) Nos quedamos con dos estrategias sencillas y efectivas:\n(1) Hardware con RC y (2) Software con m√°quina de estados usando millis().\n1) Antirrebote por hardware con filtro RC Vamos a suponer un rebote de 20 ms para simplificar. La idea es que el filtro sea un poco m√°s lento que ese rebote para que lo ‚Äúsuavice‚Äù.\nEsquema (pull-up t√≠pico): usa un pull-up a Vcc, el bot√≥n a GND, y coloca un condensador del pin a GND. C√°lculo directo: un RC se define por su constante de tiempo ( \\tau = R \\cdot C ). Queremos que (5\\tau \u0026gt; 20,\\text{ms}), as√≠ el pin no cruza varias veces el umbral durante el rebote. Ejemplo pr√°ctico (con 20 ms):\n[ R = 100,\\text{k}\\Omega, \\quad C = 47,\\text{nF} \\quad \\Rightarrow \\quad \\tau \\approx 4.7,\\text{ms} \\quad \\Rightarrow \\quad 5\\tau \\approx 23.5,\\text{ms} ]\nPLACEHOLDER IMG:\u0026nbsp; \"waveform-rc-debounce.png\" ‚Äî Rebote crudo vs salida filtrada por RC Arriba: rebote crudo. Abajo: el RC hace que el pin cruce el umbral una sola vez\nCircuito recomendado (3.3 V o 5 V, pull-up) Rpull-up = 100 kŒ© a Vcc SW1 a GND C = 47 nF del pin a GND (Opcional) Rserie = 100 Œ© con el bot√≥n para limitar picos de corriente hacia el condensador PLACEHOLDER IMG:\u0026nbsp; \"circuito-antirrebote-rc.png\" ‚Äî Esquema con Rpull-up, C al pin y Rserie Pull-up externo de 100 kŒ© + C de 47 nF ‚Üí 5œÑ ‚âà 23.5 ms\nNota: El RC a√±ade un retardo a la lectura. Si quieres m√°s rapidez, reduce un poco (R) o (C) y valida que siga filtrando bien.\n2) Antirrebote por software con millis() (no bloqueante) Usaremos una m√°quina de estados muy simple: detecta un cambio crudo, abre una ventana de estabilidad y confirma el nuevo estado si pasan ~35 ms sin m√°s cambios. No bloquea la CPU.\nconst int buttonPin = 2; // INPUT_PULLUP si no usas RC const int led = 13; const unsigned long debounceMs = 35; // ventana de estabilidad int stableState = HIGH; // reposo en HIGH (pull-up) int lastRead = HIGH; unsigned long lastEdgeMs = 0; void setup() { pinMode(buttonPin, INPUT_PULLUP); // o INPUT si usas RC externo pinMode(led, OUTPUT); } void loop() { int reading = digitalRead(buttonPin); // 1) Cambio crudo ‚Üí reinicia ventana if (reading != lastRead) { lastEdgeMs = millis(); lastRead = reading; } // 2) Pasado debounceMs sin m√°s cambios ‚Üí confirma estado if ((millis() - lastEdgeMs) \u0026gt; debounceMs \u0026amp;\u0026amp; reading != stableState) { stableState = reading; // Ejemplo: actuar al PRESIONAR (pull-up: HIGH-\u0026gt;LOW) if (stableState == LOW) { digitalWrite(led, !digitalRead(led)); // toggle } // Si prefieres actuar al SOLTAR: (stableState == HIGH) } } Tip: si usas interrupciones, es mejor llevar al pin de IRQ una se√±al ya filtrada por RC y, en la ISR, solo detectar el flanco.\nConclusi√≥n y recomendaciones (en 8 puntos) Usa millis() si no quieres tocar la PCB. Combina ambos (RC moderado + millis()) para producto robusto. Valores de arranque: RC 100 kŒ© + 47 nF (‚âà5œÑ = 23.5 ms), debounceMs 35 ms. Mide el rebote con osciloscopio; si no, dise√±a para ~20 ms y ajusta. Evita delay(); usa ventana no bloqueante con millis() o FSM. En PCB, deja pads DNF para R/C y pon el C cerca del pin (retorno GND corto). Si usas IRQ, filtra antes con RC y en la ISR solo detecta el flanco. ","date":"September 9, 2025","hero":"/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/images/circuito-antirrebote-cover.jpg","permalink":"https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/","summary":"\u003cp\u003eLos \u003cstrong\u003epulsadores\u003c/strong\u003e, \u003cstrong\u003eswitches\u003c/strong\u003e y \u003cstrong\u003erel√©s\u003c/strong\u003e est√°n en todos lados.\u003cbr\u003e\nCuando los conectamos a un microcontrolador (PIC, ESP32, Arduino, etc.) esperamos un \u003cstrong\u003ecambio de estado limpio\u003c/strong\u003e por cada pulsaci√≥n. En la pr√°ctica no ocurre as√≠: los contactos mec√°nicos \u003cstrong\u003erebotan\u003c/strong\u003e durante unos milisegundos y generan \u003cstrong\u003evarias transiciones\u003c/strong\u003e antes de estabilizarse. A esto se le llama \u003cstrong\u003erebote de contacto\u003c/strong\u003e (\u003cem\u003econtact bounce\u003c/em\u003e).\u003c/p\u003e\n\u003cdiv style=\"text-align:center; margin: 1em 0;\"\u003e\n  \u003cdiv style=\"border:2px dashed #bbb; padding:28px; width:80%; height:220px; margin:0 auto; display:flex; align-items:center; justify-content:center; color:#777;\"\u003e\n    \u003cstrong\u003ePLACEHOLDER IMG:\u003c/strong\u003e\u0026nbsp; \"button-ideal-vs-bounce.png\" ‚Äî Se√±al ideal vs con rebote\n  \u003c/div\u003e\n  \u003cp\u003e\u003cem\u003eIdeal vs. real: sin rebote (arriba) vs. con rebote (abajo)\u003c/em\u003e\u003c/p\u003e","tags":["Pulsadores","Antirrebote","Arduino","ESP32","PIC","Electr√≥nica digital"],"title":"¬øQu√© es un circuito antirrebote?"},{"categories":["Electr√≥nica","B√°sico"],"contents":"Si alguna vez has desarmado un dispositivo electr√≥nico, seguramente te has encontrado con placas verdes o azules con componentes electr√≥nicos.\nEl acr√≥nimo PCB viene del ingl√©s Printed Circuit Board y se traduce como placa de circuito impreso.\nEn pocas palabras, una PCB es una placa de fibra con pistas de cobre. Estas pistas son cables planos que conectan los componentes entre s√≠ de manera ordenada y confiable.\nUn PCB est√° formado por varias capas f√≠sicas:\nSustrato (FR4): el material base que le da rigidez. Cobre: las pistas conductoras. M√°scara de soldadura: la capa protectora, generalmente verde. Serigraf√≠a: texto blanco para identificar pines y componentes. Tipos y componentes Las PCBs se pueden clasificar de varias formas:\nN√∫mero de capas: 1 capa ‚Üí solo pistas en una cara de la placa. 2 capas ‚Üí pistas arriba y abajo, conectadas con peque√±os agujeros metalizados llamados v√≠as. Multicapa ‚Üí varias capas internas de cobre, necesarias en equipos con circuitos m√°s complejos. Tipo de montaje de componentes: Through-hole (THT) ‚Üí los pines atraviesan la placa por orificios y se sueldan al otro lado. Montaje superficial (SMD) ‚Üí los componentes se colocan directamente sobre la superficie en pads met√°licos. Software para dise√±ar PCBs El dise√±o de una PCB empieza siempre en un software CAD electr√≥nico. Algunas opciones comunes son:\nEasyEDA ‚Üí gratis, funciona en navegador, muy pr√°ctico si est√°s empezando. KiCad ‚Üí open source y completo, usado tanto por makers como en proyectos profesionales. Altium Designer ‚Üí profesional (de pago). Pasos para dise√±ar una PCB Dise√±ar el esquem√°tico\nDibujas el circuito con s√≠mbolos, que son representaciones gr√°ficas de cada componente (resistencias, chips, conectores).\nCada s√≠mbolo debe estar vinculado a una huella (footprint), que define la forma f√≠sica del componente en la PCB. Pasar al editor de PCB\nAqu√≠ defines el contorno de la placa y decides c√≥mo distribuir las huellas de los componentes.\nDespu√©s se comienza a enrutar las pistas. Estas conexiones pueden ir en la parte superior, inferior o en capas internas.\nPara conectar un lado con otro, se usan v√≠as. Generar los archivos Gerber\nSon los planos digitales que entiende la f√°brica para producir la placa.\nPuedes visualizarlos antes de mandar a fabricar en sitios como PCBWay. C√≥mo mandarlas a fabricar Hoy en d√≠a mandar a hacer PCBs es barato y r√°pido. Los pasos son:\nExporta los Gerbers de tu dise√±o. Elige un fabricante online (ejemplos: JLCPCB, PCBWay). Sube tus archivos y configura las opciones. Paga y espera. En menos de dos semanas tendr√°s tus PCBs listas. Reglas de dise√±o recomendadas Adem√°s de los consejos b√°sicos, estas reglas te ayudar√°n a evitar errores comunes:\nDefine las reglas desde el inicio\nConfigura en el software los valores deseados como: ancho de pista, separaci√≥n minima entre pistas, tama√±o de v√≠a \u0026hellip;\nColoca primero lo importante\nPon conectores y componentes grandes en su lugar, luego los ICs principales y, alrededor, los pasivos.\nMant√©n los SMD en el mismo lado para simplificar montaje.\nUsa un plano de tierra s√≥lido\nEn placas de 2 capas, dedica una cara a GND y enruta mayormente en la otra.\nAgrupa por funci√≥n\nSepara anal√≥gico, digital y potencia. As√≠ reduces interferencias y facilitas el ruteo.\nRevisa siempre con DRC/ERC\nHaz chequeos autom√°ticos y una revisi√≥n manual antes de exportar los Gerbers.\nChecklist antes de enviar a f√°brica ERC/DRC sin errores. Footprints revisados con datasheets. Revisar orientacion y polaridad de LEDs, diodos y condensadores/capacitores Plano de GND continuo (sin islas). Ancho de pistas suficiente para la corriente. Textos legibles y fuera de pads. Conectores orientados correctamente. Mounting holes y test points definidos. Gerbers revisados en el visor del fabricante. ","date":"September 8, 2025","hero":"/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/images/pcb-cover.jpg","permalink":"https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/","summary":"\u003cp\u003eSi alguna vez has desarmado un dispositivo electr√≥nico, seguramente te has encontrado con placas verdes o azules con componentes electr√≥nicos.\u003c/p\u003e\n\u003cp\u003eEl acr√≥nimo \u003cstrong\u003ePCB\u003c/strong\u003e viene del ingl√©s \u003cem\u003ePrinted Circuit Board\u003c/em\u003e y se traduce como \u003cstrong\u003eplaca de circuito impreso\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eEn pocas palabras, una PCB es una \u003cstrong\u003eplaca de fibra con pistas de cobre\u003c/strong\u003e. Estas pistas son cables planos que conectan los componentes entre s√≠ de manera ordenada y confiable.\u003c/p\u003e\n\u003cp\u003eUn PCB est√° formado por varias capas f√≠sicas:\u003c/p\u003e","tags":["PCB","Electr√≥nica","Maker","Dise√±o de PCBs","Fabricaci√≥n de circuitos"],"title":"¬øQu√© es una PCB y c√≥mo mandarlas a hacer?"},{"categories":["Electr√≥nica","Automatizaci√≥n industrial","Redes industriales"],"contents":"El est√°ndar OPC UA (Open Platform Communications Unified Architecture) es la evoluci√≥n m√°s robusta de la familia OPC. Fue dise√±ado para llevar los datos de m√°quinas, sensores y sistemas SCADA a aplicaciones empresariales o servicios en la nube sin depender de software propietario. Su propuesta combina un modelo de informaci√≥n sem√°ntico, comunicaciones orientadas a servicios y seguridad de grado industrial en una sola especificaci√≥n.\nArquitectura por capas: m√°s all√° del simple cliente-servidor A primera vista, OPC UA sigue un modelo cliente-servidor: los servidores exponen datos y m√©todos provenientes de dispositivos u otras fuentes, mientras que los clientes consumen esa informaci√≥n. Sin embargo, bajo la superficie hay una pila organizada en capas que separa transporte, codificaci√≥n y servicios para lograr interoperabilidad real.\nPLACEHOLDER IMG:\u0026nbsp; \"opc-ua-stack.png\" ‚Äî Capas de transporte, mensajes, servicios y modelo de informaci√≥n La especificaci√≥n separa cada responsabilidad para facilitar implementaciones multiplataforma.\nCapa de transporte: permite enviar mensajes sobre TCP seguro, HTTPS o incluso WebSockets para integrarse con aplicaciones web. Capa de mensajes: define c√≥mo se codifican las estructuras de datos (binario UA o JSON) y c√≥mo se gestionan sesiones, canales seguros y monitoreo. Capa de servicios: re√∫ne las operaciones b√°sicas como explorar nodos (Browse), leer y escribir valores, suscribirse a eventos o ejecutar m√©todos remotos. Modelo de informaci√≥n: describe los nodos y referencias que conforman la sem√°ntica del sistema, desde variables simples hasta objetos complejos. Este enfoque permite que un PLC, un gateway IIoT o un sistema MES hablen el mismo idioma aunque sean de fabricantes distintos.\nModelo de informaci√≥n: datos con sem√°ntica expl√≠cita En OPC UA, cada elemento se representa como un nodo dentro de un espacio de direcciones. Los nodos cuentan con atributos (nombre, identificador, tipo de dato) y referencias que los conectan entre s√≠. Adem√°s del √°rbol principal (Address Space), la especificaci√≥n introduce conceptos clave:\nTipos de datos y de variables que definen la estructura de los valores, incluyendo unidades, ingenier√≠a y restricciones. Objetos y m√©todos para encapsular equipos completos; por ejemplo, un variador puede exponer m√©todos como Start() o ResetFaults(). Vistas que filtran subconjuntos del espacio de direcciones para simplificar la navegaci√≥n de los clientes. Esta sem√°ntica estandarizada facilita la integraci√≥n con aplicaciones anal√≠ticas porque los datos no son simples registros, sino entidades con contexto industrial.\nModos de comunicaci√≥n: Polling eficiente y suscripciones OPC UA soporta dos patrones principales:\nLectura/Escritura directa: el cliente realiza solicitudes puntuales para obtener o modificar valores. Suscripciones con Monitored Items: el servidor env√≠a notificaciones cuando un valor cambia, se excede un umbral o se dispara un evento. Esto reduce tr√°fico y latencia, clave para tableros de control y sistemas de mantenimiento predictivo. Las suscripciones son flexibles: se puede elegir el intervalo de muestreo, la prioridad del mensaje y el modo de monitoreo (por ejemplo, solo cambios importantes). Adem√°s, las notificaciones pueden agruparse en Publish Responses para optimizar el uso de la red.\nSeguridad integrada desde el dise√±o El est√°ndar incorpora controles de seguridad en cada capa para operar en entornos cr√≠ticos:\nAutenticaci√≥n mutua mediante certificados X.509 para clientes y servidores. Cifrado y firmas con algoritmos modernos (RSA, ECC, AES-GCM) seg√∫n los perfiles de seguridad definidos por la especificaci√≥n. Control de acceso basado en roles, que permite asignar permisos detallados a funciones como operador, ingeniero o integrador. Auditor√≠a y eventos de seguridad que registran accesos, modificaciones y errores para cumplir requisitos normativos. Gracias a estos mecanismos, OPC UA puede exponerse m√°s all√° de la red OT sin recurrir a t√∫neles propietarios.\nPerfiles y Companion Specifications Para asegurar la interoperabilidad, la Fundaci√≥n OPC publica perfiles que agrupan capacidades m√≠nimas de clientes y servidores (por ejemplo, soporte para suscripciones o m√©todos). De este modo, un integrador puede verificar qu√© funciones garantiza cada implementaci√≥n.\nA la par, existen Companion Specifications creadas con asociaciones industriales (PLCopen, VDMA, FieldComm, entre otras) que describen modelos de informaci√≥n espec√≠ficos para robots, bombas o sistemas de energ√≠a. Esto acelera la integraci√≥n porque todos hablan el mismo idioma desde el nivel sem√°ntico.\nCasos de uso t√≠picos en la Industria 4.0 Consolidaci√≥n de datos de planta: recopila variables de PLC heterog√©neos y las entrega a sistemas MES o plataformas de anal√≠tica sin modificar la l√≥gica existente. Integraci√≥n OT/IT: un gateway OPC UA puede publicar datos hacia servicios cloud mediante MQTT o REST, actuando como puente seguro entre redes. Mantenimiento predictivo: las suscripciones permiten detectar tendencias an√≥malas en vibraci√≥n, temperatura o consumo energ√©tico y disparar alertas en tiempo real. Gemelos digitales: el modelo de informaci√≥n enriquece los datos crudos con metadatos, lo que facilita sincronizar el estado de activos f√≠sicos con representaciones virtuales. Buenas pr√°cticas para implementar OPC UA Definir namespaces propios para extensiones, manteniendo separados los identificadores est√°ndar de los personalizados. Documentar el Address Space y proporcionar archivos NodeSet a los integradores para que puedan explorar la estructura sin conectarse a planta. Aplicar segmentaci√≥n de red y certificados emitidos por una CA interna para reducir superficies de ataque. Monitorear m√©tricas del servidor (sesiones, suscripciones, tiempos de respuesta) y ajustar l√≠mites de recursos antes de que aparezcan cuellos de botella. Planificar la interoperabilidad a largo plazo, revisando las Companion Specifications relevantes y los perfiles que exigen los clientes finales. Conclusi√≥n OPC UA se ha consolidado como el est√°ndar de referencia para interoperabilidad industrial porque encapsula datos, sem√°ntica y seguridad en un marco √∫nico. Adoptarlo permite crear soluciones escalables que conectan m√°quinas antiguas con aplicaciones modernas, manteniendo el control sobre qui√©n accede a la informaci√≥n y c√≥mo se comparte. Para organizaciones que avanzan hacia la Industria 4.0, comprender sus fundamentos es el primer paso para dise√±ar arquitecturas OT/IT sostenibles y seguras.\n","date":"February 14, 2025","hero":"/images/default-hero.jpg","permalink":"https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/","summary":"\u003cp\u003eEl est√°ndar \u003cstrong\u003eOPC UA (Open Platform Communications Unified Architecture)\u003c/strong\u003e es la evoluci√≥n m√°s robusta de la familia OPC. Fue dise√±ado para llevar los datos de m√°quinas, sensores y sistemas SCADA a aplicaciones empresariales o servicios en la nube sin depender de software propietario. Su propuesta combina un \u003cstrong\u003emodelo de informaci√≥n sem√°ntico\u003c/strong\u003e, comunicaciones \u003cstrong\u003eorientadas a servicios\u003c/strong\u003e y \u003cstrong\u003eseguridad de grado industrial\u003c/strong\u003e en una sola especificaci√≥n.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"arquitectura-por-capas-m√°s-all√°-del-simple-cliente-servidor\"\u003eArquitectura por capas: m√°s all√° del simple cliente-servidor\u003c/h2\u003e\n\u003cp\u003eA primera vista, OPC UA sigue un modelo cliente-servidor: los \u003cstrong\u003eservidores\u003c/strong\u003e exponen datos y m√©todos provenientes de dispositivos u otras fuentes, mientras que los \u003cstrong\u003eclientes\u003c/strong\u003e consumen esa informaci√≥n. Sin embargo, bajo la superficie hay una pila organizada en capas que separa transporte, codificaci√≥n y servicios para lograr interoperabilidad real.\u003c/p\u003e","tags":["OPC UA","Industria 4.0","Protocolos de comunicaci√≥n","Integraci√≥n OT/IT","Ciberseguridad industrial"],"title":"¬øQu√© es OPC UA y por qu√© es clave en la automatizaci√≥n industrial?"}]