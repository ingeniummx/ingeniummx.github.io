<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ingenium MX</title><link>https://ingeniummx.github.io/</link><description>Recent content on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 18 Sep 2025 10:00:00 +0200</lastBuildDate><atom:link href="https://ingeniummx.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>¿Qué es MQTT y por qué se usa tanto en IoT?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/</link><pubDate>Thu, 18 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/</guid><description>&lt;p&gt;El &lt;strong&gt;protocolo MQTT (Message Queuing Telemetry Transport)&lt;/strong&gt; se ha convertido en el &lt;em&gt;idioma común&lt;/em&gt; de los proyectos &lt;strong&gt;IoT&lt;/strong&gt;, tanto domésticos como industriales. Es &lt;strong&gt;ligero&lt;/strong&gt;, funciona bien con enlaces inestables y permite que sensores, microcontroladores, dashboards y servicios en la nube intercambien datos sin enredarse en sockets manuales. Su modelo &lt;strong&gt;publish/subscribe&lt;/strong&gt; gira alrededor de un broker que recibe, filtra y entrega mensajes, de los clientes que publican o se suscriben, y de los temas (&lt;em&gt;topics&lt;/em&gt;) que organizan la información con rutas jerárquicas como &lt;code&gt;ingenium/sala/temperatura&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Puente H con relevadores: controla un motor DC con Arduino</title><link>https://ingeniummx.github.io/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/</link><pubDate>Tue, 16 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/</guid><description>&lt;p&gt;Un &lt;strong&gt;puente H&lt;/strong&gt; es un circuito que permite invertir el sentido de giro de un motor de corriente directa (DC) al cambiar la polaridad de alimentación entre sus terminales. Se utiliza en aplicaciones donde es necesario controlar el movimiento en ambos sentidos, como en robótica o mecanismos reversibles.&lt;/p&gt;
&lt;p&gt;En este proyecto vamos a construir un puente H sencillo utilizando un &lt;strong&gt;módulo de 2 relevadores de 5 V&lt;/strong&gt;, muy común en kits de Arduino, para controlar un motor DC de 12 V.&lt;/p&gt;</description></item><item><title>Cómo instalar Ubuntu 24.04 en Windows 11 con WSL2 paso a paso</title><link>https://ingeniummx.github.io/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/</link><pubDate>Mon, 15 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/</guid><description>&lt;p&gt;El &lt;strong&gt;Subsistema de Windows para Linux (WSL2)&lt;/strong&gt; permite correr distribuciones de Linux dentro de Windows 11, sin necesidad de crear una máquina virtual con VirtualBox ni instalar dual-boot.&lt;br&gt;
En este tutorial instalaremos &lt;strong&gt;Ubuntu 24.04 (Noble Numbat)&lt;/strong&gt;, configuraremos aplicaciones esenciales como &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;gedit&lt;/code&gt;, y prepararemos el entorno para trabajar con &lt;strong&gt;Visual Studio Code&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="1-wsl2-en-windows-11"&gt;1. WSL2 en Windows 11&lt;/h2&gt;
&lt;p&gt;Abre &lt;strong&gt;PowerShell como administrador&lt;/strong&gt; y ejecuta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-powershell" data-lang="powershell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dism.exe /online /enable-feature /featurename&lt;span style="color:#960050;background-color:#1e0010"&gt;:&lt;/span&gt;Microsoft-Windows-Subsystem-Linux /all /norestart
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dism.exe /online /enable-feature /featurename&lt;span style="color:#960050;background-color:#1e0010"&gt;:&lt;/span&gt;VirtualMachinePlatform /all /norestart
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Reinicia el equipo y verifica que WSL2 está activo:&lt;/p&gt;</description></item><item><title>¿Qué es un circuito antirrebote?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/</link><pubDate>Tue, 09 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/</guid><description>&lt;p&gt;Los &lt;strong&gt;pulsadores&lt;/strong&gt;, &lt;strong&gt;switches&lt;/strong&gt; y &lt;strong&gt;relés&lt;/strong&gt; están en todos lados.&lt;br&gt;
Cuando los conectamos a un microcontrolador (PIC, ESP32, Arduino, etc.) esperamos un &lt;strong&gt;cambio de estado limpio&lt;/strong&gt; por cada pulsación. En la práctica no ocurre así: los contactos mecánicos &lt;strong&gt;rebotan&lt;/strong&gt; durante unos milisegundos y generan &lt;strong&gt;varias transiciones&lt;/strong&gt; antes de estabilizarse. A esto se le llama &lt;strong&gt;rebote de contacto&lt;/strong&gt; (&lt;em&gt;contact bounce&lt;/em&gt;).&lt;/p&gt;
&lt;div style="text-align:center; margin: 1em 0;"&gt;
&lt;div style="border:2px dashed #bbb; padding:28px; width:80%; height:220px; margin:0 auto; display:flex; align-items:center; justify-content:center; color:#777;"&gt;
&lt;strong&gt;PLACEHOLDER IMG:&lt;/strong&gt;&amp;nbsp; "button-ideal-vs-bounce.png" — Señal ideal vs con rebote
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Ideal vs. real: sin rebote (arriba) vs. con rebote (abajo)&lt;/em&gt;&lt;/p&gt;</description></item><item><title>¿Qué es una PCB y cómo mandarlas a hacer?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/</link><pubDate>Mon, 08 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/</guid><description>&lt;p&gt;Si alguna vez has desarmado un dispositivo electrónico, seguramente te has encontrado con placas verdes o azules con componentes electrónicos.&lt;/p&gt;
&lt;p&gt;El acrónimo &lt;strong&gt;PCB&lt;/strong&gt; viene del inglés &lt;em&gt;Printed Circuit Board&lt;/em&gt; y se traduce como &lt;strong&gt;placa de circuito impreso&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;En pocas palabras, una PCB es una &lt;strong&gt;placa de fibra con pistas de cobre&lt;/strong&gt;. Estas pistas son cables planos que conectan los componentes entre sí de manera ordenada y confiable.&lt;/p&gt;
&lt;p&gt;Un PCB está formado por varias capas físicas:&lt;/p&gt;</description></item><item><title>¿Qué es OPC UA y por qué es clave en la automatización industrial?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/</link><pubDate>Fri, 14 Feb 2025 09:00:00 -0600</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/</guid><description>&lt;p&gt;El estándar &lt;strong&gt;OPC UA (Open Platform Communications Unified Architecture)&lt;/strong&gt; es la evolución más robusta de la familia OPC. Fue diseñado para llevar los datos de máquinas, sensores y sistemas SCADA a aplicaciones empresariales o servicios en la nube sin depender de software propietario. Su propuesta combina un &lt;strong&gt;modelo de información semántico&lt;/strong&gt;, comunicaciones &lt;strong&gt;orientadas a servicios&lt;/strong&gt; y &lt;strong&gt;seguridad de grado industrial&lt;/strong&gt; en una sola especificación.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-por-capas-más-allá-del-simple-cliente-servidor"&gt;Arquitectura por capas: más allá del simple cliente-servidor&lt;/h2&gt;
&lt;p&gt;A primera vista, OPC UA sigue un modelo cliente-servidor: los &lt;strong&gt;servidores&lt;/strong&gt; exponen datos y métodos provenientes de dispositivos u otras fuentes, mientras que los &lt;strong&gt;clientes&lt;/strong&gt; consumen esa información. Sin embargo, bajo la superficie hay una pila organizada en capas que separa transporte, codificación y servicios para lograr interoperabilidad real.&lt;/p&gt;</description></item><item><title>Cómo elegir el módulo ESP32 ideal para tu PCB</title><link>https://ingeniummx.github.io/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/</link><pubDate>Wed, 05 Jun 2024 10:00:00 -0600</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/</guid><description>&lt;h1 id="cómo-elegir-el-módulo-esp32-ideal-para-tu-pcb"&gt;Cómo elegir el módulo ESP32 ideal para tu PCB&lt;/h1&gt;
&lt;p&gt;La familia ESP32 es estándar en IoT por costo, Wi-Fi/BLE y ecosistema. Al pasar de prototipo a producto, la elección del &lt;strong&gt;módulo&lt;/strong&gt; impacta RF, consumo, certificación y BOM. Esta guía resume criterios &lt;strong&gt;técnicos, regulatorios y logísticos&lt;/strong&gt; para seleccionar con confianza.&lt;/p&gt;
&lt;h2 id="1-define-requisitos-del-producto"&gt;1) Define requisitos del producto&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Energía y consumo.&lt;/strong&gt; ¿Batería o línea? Filtra por &lt;em&gt;deep sleep&lt;/em&gt; (≈5 µA en C3 hasta &amp;gt;20 µA en S3) y por picos de TX (500–700 mA).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conectividad.&lt;/strong&gt; Además de Wi-Fi 2.4 GHz, hay BLE 5.x (C3/S3), 802.15.4 para Thread/Matter (C6), e incluso variantes sin Wi-Fi (H2). Elige primero la &lt;strong&gt;familia&lt;/strong&gt; por protocolo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria y periféricos.&lt;/strong&gt; TLS pesado, UI, voz/visión → &lt;strong&gt;PSRAM&lt;/strong&gt; + más flash (p.ej., WROVER, S3 8–16 MB). Sensores simples → 2–4 MB.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entorno.&lt;/strong&gt; Rango de temperatura, blindaje metálico y robustez EMI (p.ej., WROOM-32E/UE). Verifica versiones industriales.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-elige-la-familia-esp32"&gt;2) Elige la familia ESP32&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Familia&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Radios&lt;/th&gt;
&lt;th&gt;Ventajas&lt;/th&gt;
&lt;th&gt;Casos típicos&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32 (WROOM/WROVER)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Xtensa LX6&lt;/td&gt;
&lt;td&gt;Wi-Fi b/g/n, BT Classic + LE&lt;/td&gt;
&lt;td&gt;Ecosistema maduro, opciones con PSRAM&lt;/td&gt;
&lt;td&gt;Gateways, audio, TFT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-S2/S3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Xtensa (S3 con SIMD)&lt;/td&gt;
&lt;td&gt;Wi-Fi (S3: + BLE)&lt;/td&gt;
&lt;td&gt;USB OTG, aceleraciones para IA&lt;/td&gt;
&lt;td&gt;HID, cámaras/LCD, edge-AI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-C2/C3/C6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RISC-V&lt;/td&gt;
&lt;td&gt;C3: Wi-Fi + BLE; C6: + 802.15.4&lt;/td&gt;
&lt;td&gt;Bajo consumo, Matter/Thread&lt;/td&gt;
&lt;td&gt;Batería, domótica&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-H2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RISC-V&lt;/td&gt;
&lt;td&gt;BLE + 802.15.4&lt;/td&gt;
&lt;td&gt;Ultra bajo consumo, sin Wi-Fi&lt;/td&gt;
&lt;td&gt;Zigbee/Thread con pila&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Primero &lt;strong&gt;familia por protocolo/consumo&lt;/strong&gt;; luego la &lt;strong&gt;variante&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>Controlar un LED con ESP32 y MQTT</title><link>https://ingeniummx.github.io/posts/comunicaciones/controlar-un-led-con-esp32-y-mqtt/</link><pubDate>Sat, 16 Mar 2024 19:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/comunicaciones/controlar-un-led-con-esp32-y-mqtt/</guid><description>&lt;p&gt;MQTT es un protocolo ligero de mensajería ideal para IoT. Con un ESP32 y un broker local o en un VPS puedes controlar actuadores desde cualquier lugar del mundo.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="preparar-el-broker"&gt;Preparar el broker&lt;/h2&gt;
&lt;h3 id="opción-local-mosquitto"&gt;Opción local (Mosquitto)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo apt update
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo apt install mosquitto mosquitto-clients
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo systemctl enable --now mosquitto
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="opción-vps"&gt;Opción VPS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Contrata un VPS ligero (1 vCPU, 1 GB RAM).&lt;/li&gt;
&lt;li&gt;Instala Mosquitto y configura autenticación básica en &lt;code&gt;/etc/mosquitto/conf.d/seguro.conf&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;allow_anonymous false
password_file /etc/mosquitto/passwd
listener 8883
cafile /etc/letsencrypt/live/tu-dominio/fullchain.pem
keyfile /etc/letsencrypt/live/tu-dominio/privkey.pem
certfile /etc/letsencrypt/live/tu-dominio/fullchain.pem
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="3"&gt;
&lt;li&gt;Genera certificados TLS con Let’s Encrypt y crea usuarios con &lt;code&gt;mosquitto_passwd&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="firmware-esp32-arduino-core"&gt;Firmware ESP32 (Arduino core)&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;WiFi.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;PubSubClient.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; ssid &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;TuRed&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; password &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;TuClave&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; mqtt_server &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;broker.tudominio.com&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; mqtt_port &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;8883&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;WiFiClientSecure espClient;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;PubSubClient &lt;span style="color:#a6e22e"&gt;client&lt;/span&gt;(espClient);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; ledPin &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;callback&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; topic, byte&lt;span style="color:#f92672"&gt;*&lt;/span&gt; payload, &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; length) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; String mensaje;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; length; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;) mensaje &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;)payload[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; digitalWrite(ledPin, mensaje &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;ON&amp;#34;&lt;/span&gt; &lt;span style="color:#f92672"&gt;?&lt;/span&gt; HIGH : LOW);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;reconnect&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (&lt;span style="color:#f92672"&gt;!&lt;/span&gt;client.connected()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (client.connect(&lt;span style="color:#e6db74"&gt;&amp;#34;esp32-led&amp;#34;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#34;usuario&amp;#34;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#34;password&amp;#34;&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; client.subscribe(&lt;span style="color:#e6db74"&gt;&amp;#34;casa/sala/led&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; } &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; delay(&lt;span style="color:#ae81ff"&gt;2000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;setup&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; pinMode(ledPin, OUTPUT);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Serial.begin(&lt;span style="color:#ae81ff"&gt;115200&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; WiFi.begin(ssid, password);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (WiFi.status() &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; WL_CONNECTED) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; delay(&lt;span style="color:#ae81ff"&gt;500&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; espClient.setCACert(&lt;span style="color:#e6db74"&gt;&amp;#34;-----BEGIN CERTIFICATE-----&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;...&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;-----END CERTIFICATE-----&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; client.setServer(mqtt_server, mqtt_port);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; client.setCallback(callback);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;loop&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#f92672"&gt;!&lt;/span&gt;client.connected()) reconnect();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; client.loop();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Para conexiones sin TLS ajusta el puerto 1883 y elimina &lt;code&gt;setCACert&lt;/code&gt;, pero prioriza seguridad en despliegues reales.&lt;/p&gt;</description></item><item><title>FPGAs</title><link>https://ingeniummx.github.io/posts/hardware-digital/fpgas/</link><pubDate>Sat, 16 Mar 2024 19:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/hardware-digital/fpgas/</guid><description>&lt;p&gt;Las &lt;strong&gt;FPGAs (Field Programmable Gate Arrays)&lt;/strong&gt; son dispositivos lógicos reconfigurables que permiten implementar hardware personalizado mediante lenguajes HDL. Ofrecen paralelismo masivo y tiempos deterministas que superan a los microcontroladores convencionales en tareas específicas.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-básica"&gt;Arquitectura básica&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bloques lógicos configurables (CLB):&lt;/strong&gt; contienen LUTs, flip-flops y multiplexores.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red de interconexión programable:&lt;/strong&gt; conecta LUTs y bloques especializados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bloques de memoria (BRAM) y UltraRAM:&lt;/strong&gt; almacenamiento de baja latencia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSP slices:&lt;/strong&gt; multiplicadores y acumuladores optimizados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O programables:&lt;/strong&gt; soportan estándares LVDS, LVCMOS, SerDes, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-diseño"&gt;Flujo de diseño&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Descripción HDL&lt;/strong&gt; (VHDL, Verilog, SystemVerilog) o herramientas de alto nivel (HLS, OpenCL).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sintetizado&lt;/strong&gt;: convierte el HDL en una red lógica.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implementación (place &amp;amp; route):&lt;/strong&gt; asigna recursos físicos y rutas de interconexión.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generación de bitstream&lt;/strong&gt;: archivo que configura la FPGA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Programación&lt;/strong&gt; mediante JTAG, SPI flash o procesadores integrados.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="familias-populares"&gt;Familias populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Fabricante&lt;/th&gt;
&lt;th&gt;Serie&lt;/th&gt;
&lt;th&gt;Rasgos&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Xilinx/AMD&lt;/td&gt;
&lt;td&gt;Artix-7, Kintex-7, Zynq&lt;/td&gt;
&lt;td&gt;Buena relación costo/rendimiento, SoC con ARM Cortex-A9.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel/Altera&lt;/td&gt;
&lt;td&gt;Cyclone V, MAX 10, Arria&lt;/td&gt;
&lt;td&gt;Opciones desde bajo costo hasta alto desempeño.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lattice&lt;/td&gt;
&lt;td&gt;iCE40, ECP5, Nexus&lt;/td&gt;
&lt;td&gt;Bajo consumo, ideales para IoT y dispositivos portátiles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gowin&lt;/td&gt;
&lt;td&gt;LittleBee, Arora&lt;/td&gt;
&lt;td&gt;Alternativa económica con herramientas accesibles.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="aplicaciones"&gt;Aplicaciones&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Procesamiento de señales&lt;/strong&gt; (radar, SDR, visión por computadora).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Puentes de comunicación&lt;/strong&gt; (PCIe, Ethernet, protocolos personalizados).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Control industrial&lt;/strong&gt; con tiempos deterministas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prototipado de ASIC&lt;/strong&gt; y emulación de hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-herramientas"&gt;Ecosistema de herramientas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Vivado / Vitis&lt;/strong&gt; (Xilinx), &lt;strong&gt;Quartus Prime&lt;/strong&gt; (Intel), &lt;strong&gt;Radiant / Diamond&lt;/strong&gt; (Lattice).&lt;/li&gt;
&lt;li&gt;Flujos open source: &lt;strong&gt;Yosys + nextpnr&lt;/strong&gt;, &lt;strong&gt;SymbiFlow&lt;/strong&gt;, &lt;strong&gt;OpenFPGA&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Lenguajes de alto nivel: &lt;strong&gt;Migen&lt;/strong&gt;, &lt;strong&gt;nMigen&lt;/strong&gt;, &lt;strong&gt;Chisel&lt;/strong&gt;, &lt;strong&gt;SpinalHDL&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-principiantes"&gt;Consejos para principiantes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Empieza con placas accesibles (iCEstick, DE0-Nano, Arty A7).&lt;/li&gt;
&lt;li&gt;Practica con diseños simples: contadores, PWM, UART.&lt;/li&gt;
&lt;li&gt;Usa &lt;strong&gt;simulación&lt;/strong&gt; (GHDL, ModelSim) antes de sintetizar para atrapar bugs.&lt;/li&gt;
&lt;li&gt;Gestiona los &lt;strong&gt;constraints&lt;/strong&gt; de tiempo y pines en archivos &lt;code&gt;.xdc&lt;/code&gt; o &lt;code&gt;.sdc&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Documenta versiones de herramientas; pequeñas diferencias pueden cambiar resultados.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con esta base podrás adentrarte en el mundo de las FPGAs y escoger la plataforma adecuada para tus proyectos de diseño digital.&lt;/p&gt;</description></item><item><title>Instalar micro-ROS en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 18:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</guid><description>&lt;p&gt;&lt;strong&gt;micro-ROS&lt;/strong&gt; lleva ROS 2 a microcontroladores con recursos limitados. A continuación se describe cómo configurar el build system para la Raspberry Pi Pico utilizando el Pico SDK oficial.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="prerrequisitos"&gt;Prerrequisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Toolchain Arm (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt;), CMake y Ninja.&lt;/li&gt;
&lt;li&gt;ROS 2 Humble (o posterior) instalado en tu sistema.&lt;/li&gt;
&lt;li&gt;Repositorio &lt;code&gt;micro_ros_setup&lt;/code&gt; clonado en el workspace de ROS 2.&lt;/li&gt;
&lt;li&gt;Pico SDK inicializado (&lt;code&gt;PICO_SDK_PATH&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="configurar-el-workspace"&gt;Configurar el workspace&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source /opt/ros/humble/setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/micro-ROS/micro_ros_setup.git
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ..
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;colcon build
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source install/local_setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="crear-firmware-para-la-pico"&gt;Crear firmware para la Pico&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Importa los repositorios necesarios&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup create_firmware_ws.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;Descarga dependencias&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup configure_firmware.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;Compila&lt;/strong&gt; con opciones personalizadas (Wi-Fi deshabilitada por defecto):&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup build_firmware.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="4"&gt;
&lt;li&gt;El resultado (&lt;code&gt;firmware.uf2&lt;/code&gt;) se genera en &lt;code&gt;firmware/build&lt;/code&gt;. Cópialo a la Pico en modo BOOTSEL.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-nodo-ping"&gt;Ejemplo: nodo ping&lt;/h2&gt;
&lt;p&gt;Tras flashear, conecta la Pico por USB y ejecuta en el host:&lt;/p&gt;</description></item><item><title>Ampliar entradas digitales con I2C</title><link>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</link><pubDate>Sat, 16 Mar 2024 18:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</guid><description>&lt;p&gt;Cuando el número de GPIO de la Raspberry Pi Pico no basta, puedes &lt;strong&gt;ampliar entradas digitales&lt;/strong&gt; con expansores I2C. Estos integrados entregan 8, 16 o más pines configurables sin sacrificar recursos del microcontrolador.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="expansores-populares"&gt;Expansores populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chip&lt;/th&gt;
&lt;th&gt;Bits&lt;/th&gt;
&lt;th&gt;Voltaje&lt;/th&gt;
&lt;th&gt;Características&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MCP23017&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;1,8–5,5 V&lt;/td&gt;
&lt;td&gt;Dos bancos de 8 bits, interrupciones configurables, pull-ups internos.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PCF8575&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–5,5 V&lt;/td&gt;
&lt;td&gt;Entradas/salidas quasi-bidireccionales, ideal para lectura de botones.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCA9555&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,3–5,5 V&lt;/td&gt;
&lt;td&gt;Interrupciones separadas, compatible con 400 kHz.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SX1509&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–3,6 V&lt;/td&gt;
&lt;td&gt;PWM por pin, debounce interno y lógica de interrupciones avanzada.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="conexión-básica"&gt;Conexión básica&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Conecta SDA y SCL al bus I2C de la Pico (GPIO 4 y 5 por defecto) con &lt;strong&gt;pull-ups de 4,7 kΩ&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Alimenta el expansor con 3,3 V o el voltaje requerido.&lt;/li&gt;
&lt;li&gt;Configura las direcciones mediante pines A0-A2.&lt;/li&gt;
&lt;li&gt;Conecta pines de interrupción (INTA/INTB) a GPIO disponibles para detectar cambios sin sondeo constante.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-con-mcp23017-en-micropython"&gt;Ejemplo con MCP23017 en MicroPython&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; machine &lt;span style="color:#f92672"&gt;import&lt;/span&gt; I2C, Pin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; mcp23017 &lt;span style="color:#f92672"&gt;import&lt;/span&gt; MCP23017
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;i2c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; I2C(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, scl&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;), sda&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;), freq&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;400000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp &lt;span style="color:#f92672"&gt;=&lt;/span&gt; MCP23017(i2c, address&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0x20&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado0 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado1 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;# Procesa botones&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;En C/C++ utiliza la librería &lt;code&gt;hardware/i2c.h&lt;/code&gt; y escribe a los registros &lt;code&gt;IODIRA&lt;/code&gt;, &lt;code&gt;GPPUA&lt;/code&gt; y &lt;code&gt;GPIOA&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Capacitancia parasitaria en PCBs</title><link>https://ingeniummx.github.io/posts/electronica/capacitancia-parasitaria-en-pcbs/</link><pubDate>Sat, 16 Mar 2024 17:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/capacitancia-parasitaria-en-pcbs/</guid><description>&lt;p&gt;La &lt;strong&gt;capacitancia parasitaria&lt;/strong&gt; aparece de forma no intencional entre pistas, planos y componentes. En circuitos de alta velocidad puede degradar bordes, generar diafonía y alterar la respuesta en frecuencia.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="de-dónde-proviene"&gt;De dónde proviene&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pistas paralelas:&lt;/strong&gt; forman capacitores distribuidos cuando corren cercanas durante largos trayectos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pads y planos de referencia:&lt;/strong&gt; cada pad hacia un plano crea capacitancia que modifica la impedancia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Componentes discretos:&lt;/strong&gt; encapsulados, cables y conectores poseen capacitancias internas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Se aproxima con:&lt;/p&gt;</description></item><item><title>Protección contra inversión de polaridad</title><link>https://ingeniummx.github.io/posts/electronica/protecci%C3%B3n-contra-inversi%C3%B3n-de-polaridad/</link><pubDate>Sat, 16 Mar 2024 17:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/protecci%C3%B3n-contra-inversi%C3%B3n-de-polaridad/</guid><description>&lt;p&gt;Conectar una fuente al revés puede destruir componentes y pistas. Implementar &lt;strong&gt;protección contra inversión de polaridad&lt;/strong&gt; es obligatorio en PCBs expuestas a usuarios finales o mantenimiento en campo.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="métodos-comunes"&gt;Métodos comunes&lt;/h2&gt;
&lt;h3 id="diodo-en-serie"&gt;Diodo en serie&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Coloca un diodo Schottky en serie con la entrada.&lt;/li&gt;
&lt;li&gt;Ventaja: simplicidad extrema.&lt;/li&gt;
&lt;li&gt;Desventaja: caída de tensión (~0,3–0,5 V) y pérdida de potencia.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="diodo-en-paralelo--fusible"&gt;Diodo en paralelo + fusible&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Diodo TVS o rectificador en antiparalelo, fusible o PTC en serie.&lt;/li&gt;
&lt;li&gt;Si se invierte la polaridad, el diodo conduce y el fusible abre.&lt;/li&gt;
&lt;li&gt;Adecuado para fuentes de alto voltaje con usuarios experimentados.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mosfet-de-canal-p"&gt;MOSFET de canal P&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura un MOSFET P-channel con el cuerpo diode apuntando hacia la carga.&lt;/li&gt;
&lt;li&gt;Ofrece baja caída de tensión (mΩ) y protección bidireccional limitada.&lt;/li&gt;
&lt;li&gt;Cuidado con el &lt;strong&gt;V_GS max&lt;/strong&gt; al usar fuentes por encima de 20 V.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mosfet-de-canal-n-ideal"&gt;MOSFET de canal N ideal&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Usa un MOSFET N con controlador de puerta ideal (por ejemplo, &lt;strong&gt;LTC4365&lt;/strong&gt;, &lt;strong&gt;LM5060&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Proporciona protección bidireccional, limitación de corriente y detección de sobrevoltaje.&lt;/li&gt;
&lt;li&gt;Recomendado en fuentes industriales y baterías Li-ion de alto corriente.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consideraciones-de-diseño"&gt;Consideraciones de diseño&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Rango de voltaje:&lt;/strong&gt; dimensiona componentes para el máximo esperado más margen.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Corriente nominal:&lt;/strong&gt; MOSFET con (R_{DS(on)}) bajo y disipación calculada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Respuesta térmica:&lt;/strong&gt; añade planos de cobre y vias para disipar calor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Diagnóstico:&lt;/strong&gt; LEDs o indicadores que alerten de polaridad invertida.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pruebas:&lt;/strong&gt; aplica inversión con fuentes limitadas en corriente para validar que no se dañe la placa.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="layout-pcb"&gt;Layout PCB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Coloca la protección cerca del conector de entrada.&lt;/li&gt;
&lt;li&gt;Usa pistas cortas y anchas para reducir inductancia.&lt;/li&gt;
&lt;li&gt;Añade TVS adicionales para transientes rápidos.&lt;/li&gt;
&lt;li&gt;Documenta claramente la polaridad en serigrafía y manuales.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con estas estrategias podrás diseñar PCBs robustas que soporten errores de conexión sin comprometer el rendimiento.&lt;/p&gt;</description></item><item><title>Cambiadores de rango con op-amps</title><link>https://ingeniummx.github.io/posts/electronica/cambiadores-de-rango-con-op-amps/</link><pubDate>Sat, 16 Mar 2024 16:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/cambiadores-de-rango-con-op-amps/</guid><description>&lt;p&gt;Cuando un sensor entrega una señal fuera del rango de tu ADC o instrumento, necesitas un &lt;strong&gt;cambiador de rango&lt;/strong&gt;. Con amplificadores operacionales puedes desplazar y escalar niveles para aprovechar mejor la resolución disponible.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="objetivo-de-diseño"&gt;Objetivo de diseño&lt;/h2&gt;
&lt;p&gt;Queremos transformar una señal (V_{in}) en (V_{out}) según:&lt;/p&gt;
&lt;p&gt;[
V_{out} = a V_{in} + b
]&lt;/p&gt;
&lt;p&gt;donde (a) es la ganancia y (b) el offset. Un circuito sumador/restador con op-amp no inversor logra este comportamiento.&lt;/p&gt;</description></item><item><title>Transcribir audio con Whisper</title><link>https://ingeniummx.github.io/posts/software/transcribir-audio-con-whisper/</link><pubDate>Sat, 16 Mar 2024 16:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/software/transcribir-audio-con-whisper/</guid><description>&lt;p&gt;&lt;strong&gt;Whisper&lt;/strong&gt; es un modelo de reconocimiento de voz multilingüe de código abierto creado por OpenAI. Permite transcribir audio a texto con alta precisión sin depender de servicios en la nube.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="requisitos"&gt;Requisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.8 o superior.&lt;/li&gt;
&lt;li&gt;Pip y virtualenv.&lt;/li&gt;
&lt;li&gt;FFmpeg instalado en el sistema (necesario para convertir formatos de audio).&lt;/li&gt;
&lt;li&gt;GPU opcional (CUDA) para acelerar inferencias con modelos grandes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instala FFmpeg en Linux con &lt;code&gt;sudo apt install ffmpeg&lt;/code&gt; o usa los binarios oficiales en Windows/macOS.&lt;/p&gt;</description></item><item><title>Lidar</title><link>https://ingeniummx.github.io/posts/sensores/lidar/</link><pubDate>Sat, 16 Mar 2024 15:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/sensores/lidar/</guid><description>&lt;p&gt;Los sistemas &lt;strong&gt;Lidar (Light Detection and Ranging)&lt;/strong&gt; miden distancias con láser y generan mapas de alta resolución. Son esenciales en SLAM, vehículos autónomos e inspección industrial.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="tecnologías-principales"&gt;Tecnologías principales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Lidar rotativo 2D:&lt;/strong&gt; un láser gira 360° en un plano horizontal. Ejemplos: RPLidar A2, Hokuyo UST.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lidar rotativo 3D:&lt;/strong&gt; varias líneas láser (Velodyne, Ouster) o inclinación mecánica para generar nubes 3D.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solid-state (MEMS, flash, FMCW):&lt;/strong&gt; sin partes móviles, menor tamaño y costo creciente en automoción.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time-of-Flight directo vs FMCW:&lt;/strong&gt; ToF mide tiempo, FMCW mide frecuencia y obtiene velocidad relativa.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="parámetros-clave"&gt;Parámetros clave&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Alcance:&lt;/strong&gt; distancia máxima efectiva para objetos con reflectividad estándar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Frecuencia de escaneo:&lt;/strong&gt; Hz o RPM; determina cuántos datos por segundo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resolución angular:&lt;/strong&gt; separación entre mediciones; influye en densidad de nube.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Campo de visión (FoV):&lt;/strong&gt; horizontal y vertical.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Precisión y repetibilidad:&lt;/strong&gt; error absoluto y ruido entre mediciones.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clase láser:&lt;/strong&gt; seguridad ocular (Clase 1 preferida para interiores).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="comparativa-rápida"&gt;Comparativa rápida&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modelo&lt;/th&gt;
&lt;th&gt;Tipo&lt;/th&gt;
&lt;th&gt;Alcance&lt;/th&gt;
&lt;th&gt;Frecuencia&lt;/th&gt;
&lt;th&gt;Nota destacada&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RPLidar A1&lt;/td&gt;
&lt;td&gt;2D&lt;/td&gt;
&lt;td&gt;12 m&lt;/td&gt;
&lt;td&gt;5–10 Hz&lt;/td&gt;
&lt;td&gt;Económico para hobby, sin protección polvo.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Slamtec S1&lt;/td&gt;
&lt;td&gt;2D&lt;/td&gt;
&lt;td&gt;40 m&lt;/td&gt;
&lt;td&gt;10–20 Hz&lt;/td&gt;
&lt;td&gt;IP65, lidar doble motor.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hokuyo UST-10LX&lt;/td&gt;
&lt;td&gt;2D&lt;/td&gt;
&lt;td&gt;10 m&lt;/td&gt;
&lt;td&gt;40 Hz&lt;/td&gt;
&lt;td&gt;Industrial, interfaz Ethernet.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ouster OS1&lt;/td&gt;
&lt;td&gt;3D solid-state&lt;/td&gt;
&lt;td&gt;120 m&lt;/td&gt;
&lt;td&gt;10–20 Hz&lt;/td&gt;
&lt;td&gt;Alta densidad, APIs ROS listas.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Livox MID-360&lt;/td&gt;
&lt;td&gt;3D no rotativo&lt;/td&gt;
&lt;td&gt;70 m&lt;/td&gt;
&lt;td&gt;20 Hz&lt;/td&gt;
&lt;td&gt;Escaneo no repetitivo con fusión temporal.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="integración-en-robots"&gt;Integración en robots&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Montaje rígido&lt;/strong&gt; y calibración de transformaciones TF para ROS/ROS 2.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincronización temporal&lt;/strong&gt; con IMU o cámaras para SLAM preciso.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtrado de ruido&lt;/strong&gt; (VoxelGrid, StatisticalOutlierRemoval) antes de alimentar algoritmos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gestión de energía&lt;/strong&gt;: algunos modelos consumen &amp;gt;10 W, planifica la fuente.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="buenas-prácticas"&gt;Buenas prácticas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mantén &lt;strong&gt;superficies limpias&lt;/strong&gt;; polvo o insectos generan falsos positivos.&lt;/li&gt;
&lt;li&gt;Usa &lt;strong&gt;zonas de exclusión&lt;/strong&gt; en software para ignorar partes del robot.&lt;/li&gt;
&lt;li&gt;Configura &lt;strong&gt;firmware y drivers oficiales&lt;/strong&gt; para aprovechar actualizaciones de calibración.&lt;/li&gt;
&lt;li&gt;Considera &lt;strong&gt;climatización&lt;/strong&gt; si operas en exterior (calentadores, deshumidificadores).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con estos criterios podrás elegir e integrar un Lidar acorde a tus necesidades de navegación y percepción.&lt;/p&gt;</description></item><item><title>Sensores ultrasónicos</title><link>https://ingeniummx.github.io/posts/sensores/sensores-ultras%C3%B3nicos/</link><pubDate>Sat, 16 Mar 2024 15:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/sensores/sensores-ultras%C3%B3nicos/</guid><description>&lt;p&gt;Los &lt;strong&gt;sensores ultrasónicos&lt;/strong&gt; miden distancia calculando el tiempo que tarda un pulso acústico en viajar y regresar desde un obstáculo. Son económicos y útiles en robótica móvil, medición de nivel y domótica.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="componentes-clave"&gt;Componentes clave&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Transductor emisor/receptor&lt;/strong&gt; piezoeléctrico (~40 kHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Driver&lt;/strong&gt; que genera burst de alta tensión (80–120 Vpp en modelos industriales).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Detector de eco&lt;/strong&gt; con amplificación logarítmica.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controlador&lt;/strong&gt; que mide el tiempo de vuelo (ToF) y entrega una lectura digital o analógica.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La distancia se calcula como:&lt;/p&gt;</description></item><item><title>Sensores Hall</title><link>https://ingeniummx.github.io/posts/sensores/sensores-hall/</link><pubDate>Sat, 16 Mar 2024 14:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/sensores/sensores-hall/</guid><description>&lt;p&gt;El &lt;strong&gt;efecto Hall&lt;/strong&gt; describe la diferencia de potencial que aparece cuando un conductor con corriente atraviesa un campo magnético. Los sensores Hall aprovechan este fenómeno para medir posición, velocidad o corriente sin contacto mecánico.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="tipos-principales"&gt;Tipos principales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Hall digital tipo interruptor:&lt;/strong&gt; salida on/off con histéresis. Usados en detección de proximidad, finales de carrera o conmutación de motores BLDC.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hall latch (bipolares):&lt;/strong&gt; cambian de estado al detectar polos norte/sur, ideales para codificadores magnéticos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hall lineales:&lt;/strong&gt; entregan una tensión proporcional al campo (V_{out} = V_{ref} + S \cdot B), donde (S) es la sensibilidad.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sensores Hall de corriente:&lt;/strong&gt; combinan un conductor y núcleo magnético para medir corriente en bus.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="aplicaciones-en-motores"&gt;Aplicaciones en motores&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Conmutación BLDC:&lt;/strong&gt; tres sensores ubicados a 120° eléctricos generan la secuencia de activación de fases.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Detección de rotor en motores paso a paso híbridos&lt;/strong&gt; cuando se requiere feedback adicional.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protección contra sobrecorriente&lt;/strong&gt; en drivers mediante Hall lineales integrados.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="integración-en-encoders"&gt;Integración en encoders&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Encoders magnéticos como &lt;strong&gt;AS5048&lt;/strong&gt;, &lt;strong&gt;MA730&lt;/strong&gt; o &lt;strong&gt;TLE5012&lt;/strong&gt; usan un imán diametral y sensores Hall 2D/3D.&lt;/li&gt;
&lt;li&gt;La resolución depende del ASIC (hasta 14 bits) y la alineación axial del imán.&lt;/li&gt;
&lt;li&gt;Proporcionan interfaces SPI, I²C, PWM o ABI (A/B/Z) compatibles con sistemas existentes.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="diseño-con-sensores-hall"&gt;Diseño con sensores Hall&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Colocación del imán:&lt;/strong&gt; asegura una distancia uniforme. Usa imanes diametrales o multipolares según la aplicación.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blindaje y ruido:&lt;/strong&gt; filtra con capacitores y protege contra campos externos fuertes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación estable:&lt;/strong&gt; muchos sensores usan referencias internas de 2,5 V; añade bypass de 100 nF + 1 µF.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Calibración:&lt;/strong&gt; aplica offsets y escalas vía firmware para corregir tolerancias.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="selección-del-sensor"&gt;Selección del sensor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rango de campo:&lt;/strong&gt; elige un dispositivo cuyo rango abarque tu campo máximo sin saturación.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sensibilidad y ruido:&lt;/strong&gt; evalúa densidad espectral de ruido para mediciones precisas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temperatura:&lt;/strong&gt; para aplicaciones automotrices busca rangos -40 a 150 °C.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Salida:&lt;/strong&gt; digital open-drain, push-pull, analógica ratiométrica o PWM.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Comprender estas variables te permitirá integrar sensores Hall de forma confiable en sistemas de motores, encoders y medición de corriente.&lt;/p&gt;</description></item><item><title>Encoders</title><link>https://ingeniummx.github.io/posts/sensores/encoders/</link><pubDate>Sat, 16 Mar 2024 14:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/sensores/encoders/</guid><description>&lt;p&gt;Los &lt;strong&gt;encoders&lt;/strong&gt; convierten movimiento en señales eléctricas para medir posición, velocidad o dirección. Son fundamentales en robótica, CNC y servo sistemas.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="clasificación-principal"&gt;Clasificación principal&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tipo&lt;/th&gt;
&lt;th&gt;Principio&lt;/th&gt;
&lt;th&gt;Resolución típica&lt;/th&gt;
&lt;th&gt;Ventajas&lt;/th&gt;
&lt;th&gt;Desventajas&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Incremental óptico&lt;/td&gt;
&lt;td&gt;Interrupción de luz LED-fotorreceptor&lt;/td&gt;
&lt;td&gt;100–10.000 PPR&lt;/td&gt;
&lt;td&gt;Alta precisión, señales cuadratura.&lt;/td&gt;
&lt;td&gt;Sensibles al polvo, requieren referencia absoluta externa.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Incremental magnético&lt;/td&gt;
&lt;td&gt;Sensor Hall/magnetorresistivo&lt;/td&gt;
&lt;td&gt;32–2048 PPR&lt;/td&gt;
&lt;td&gt;Robustos, toleran suciedad.&lt;/td&gt;
&lt;td&gt;Menor precisión angular.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Absoluto óptico&lt;/td&gt;
&lt;td&gt;Código Gray en disco&lt;/td&gt;
&lt;td&gt;10–20 bits&lt;/td&gt;
&lt;td&gt;Posición única sin homing.&lt;/td&gt;
&lt;td&gt;Costosos, tamaño mayor.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Absoluto magnético&lt;/td&gt;
&lt;td&gt;Sensor Hall 3D + ASIC&lt;/td&gt;
&lt;td&gt;12–16 bits&lt;/td&gt;
&lt;td&gt;Compactos, soportan vibración.&lt;/td&gt;
&lt;td&gt;Requieren calibración precisa del imán.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lineales (regla óptica/magnética)&lt;/td&gt;
&lt;td&gt;Codificación incremental o absoluta&lt;/td&gt;
&lt;td&gt;1–10 µm&lt;/td&gt;
&lt;td&gt;CNC y metrología.&lt;/td&gt;
&lt;td&gt;Instalación compleja.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="señales-y-conexiones"&gt;Señales y conexiones&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cuadratura A/B&lt;/strong&gt;: permite detectar dirección y multiplicar la resolución x4 con flancos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Index (Z)&lt;/strong&gt;: referencia una vuelta completa.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Salida push-pull u open-collector&lt;/strong&gt;: elige drivers compatibles con tu PLC o microcontrolador.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces absolutas&lt;/strong&gt;: SSI, BiSS-C, CANopen, EtherCAT, I²C/SPI en modelos compactos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="seleccionar-un-encoder"&gt;Seleccionar un encoder&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Resolución necesaria&lt;/strong&gt;: determina pulsos por revolución (PPR) o bits. Considera reducción mecánica y microstepping.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Velocidad máxima&lt;/strong&gt;: verifica frecuencia de salida (f = \text{PPR} \times \text{RPM} / 60) para dimensionar entradas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ambiente&lt;/strong&gt;: polvo, vibración, temperatura. Escoge IP adecuado y sellado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Montaje&lt;/strong&gt;: eje sólido, hueco, sin rodamientos (kit encoder), acople flexible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protocolo&lt;/strong&gt;: compatibilidad con controladores existentes.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="aplicaciones-típicas"&gt;Aplicaciones típicas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Servomotores AC/DC&lt;/strong&gt; con control de posición.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Robots móviles&lt;/strong&gt; para odometría diferencial.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Impresoras 3D y CNC&lt;/strong&gt; para realimentar husillos o camas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentación&lt;/strong&gt; en metrología y mesas de inspección.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="buenas-prácticas"&gt;Buenas prácticas&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alinea mecánicamente&lt;/strong&gt; el eje y usa acoples flexibles para evitar cargas radiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protege el cableado&lt;/strong&gt; con pares trenzados y blindaje conectado a tierra por un extremo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implementa homing seguro&lt;/strong&gt; aun con encoders absolutos para validar límites físicos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtra ruido&lt;/strong&gt; con entradas diferenciales (RS-422) y filtros digitales en firmware.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Comprender estas variables te permitirá seleccionar el encoder adecuado y garantizar lecturas confiables en tus sistemas de control de movimiento.&lt;/p&gt;</description></item><item><title>Programar la Pico en C++</title><link>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</link><pubDate>Sat, 16 Mar 2024 13:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</guid><description>&lt;p&gt;Programar la Raspberry Pi Pico directamente en C/C++ ofrece máximo control sobre el hardware y mejor desempeño que las capas de compatibilidad Arduino. Estos son los pasos clave para configurar el entorno oficial &lt;strong&gt;Pico SDK&lt;/strong&gt; en Windows, Linux o macOS.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="requisitos-previos"&gt;Requisitos previos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Toolchain Arm GCC&lt;/strong&gt; (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; y &lt;code&gt;newlib&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMake ≥ 3.13&lt;/strong&gt; y &lt;strong&gt;Ninja&lt;/strong&gt; o Make.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 3&lt;/strong&gt; para scripts auxiliares.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt; para clonar el SDK y submódulos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En Windows se recomienda usar &lt;strong&gt;WSL&lt;/strong&gt; o el instalador oficial que empaqueta todas las dependencias.&lt;/p&gt;</description></item><item><title>Módulos PIO en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 13:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</guid><description>&lt;p&gt;Los &lt;strong&gt;módulos PIO (Programmable I/O)&lt;/strong&gt; del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-pio"&gt;Arquitectura PIO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Máquinas de estado:&lt;/strong&gt; hasta 4 por bloque, cada una con 32 instrucciones de 16 bits.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO TX/RX:&lt;/strong&gt; buffers de 4 palabras para intercambio con la CPU o DMA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins flexibles:&lt;/strong&gt; mapeo independiente para entrada, salida y side-set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock divider:&lt;/strong&gt; ajusta la frecuencia de ejecución con resolución fraccional.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-trabajo"&gt;Flujo de trabajo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Escribe el programa PIO en ensamblador específico (&lt;code&gt;.program&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Carga el código en la instrucción memory del bloque PIO.&lt;/li&gt;
&lt;li&gt;Configura los registros de control (SM, clocks, pins).&lt;/li&gt;
&lt;li&gt;Usa la API del SDK o MicroPython para enviar/recibir datos.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplos-prácticos"&gt;Ejemplos prácticos&lt;/h2&gt;
&lt;h3 id="ws2812-neopixel"&gt;WS2812 (NeoPixel)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Genera los pulsos de 800 kHz con side-set para controlar tiras RGB.&lt;/li&gt;
&lt;li&gt;Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interfaces-vgadvi"&gt;Interfaces VGA/DVI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas.&lt;/li&gt;
&lt;li&gt;Requiere DMA para alimentar los buffers a alta velocidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="captura-de-señales"&gt;Captura de señales&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura una máquina PIO en modo &lt;code&gt;IN&lt;/code&gt; para muestrear pines a alta frecuencia.&lt;/li&gt;
&lt;li&gt;Vuelca los datos a memoria mediante DMA para análisis posterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-de-implementación"&gt;Consejos de implementación&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Planifica el ancho de palabra.&lt;/strong&gt; Ajusta &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt; y shift registers para empaquetar datos eficientemente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Utiliza DMA.&lt;/strong&gt; Mantiene alimentadas las FIFOs sin bloquear la CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Divide funciones entre máquinas.&lt;/strong&gt; Un bloque puede generar reloj y otro manejar datos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura con &lt;code&gt;pioasm&lt;/code&gt;.&lt;/strong&gt; El SDK incluye herramientas para validar el programa antes de compilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincroniza con IRQ.&lt;/strong&gt; Usa interrupciones PIO para coordinar eventos con el firmware principal.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="recursos-adicionales"&gt;Recursos adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Documentación oficial del &lt;strong&gt;RP2040 Datasheet&lt;/strong&gt; (capítulo PIO).&lt;/li&gt;
&lt;li&gt;Ejemplos del &lt;strong&gt;Pico SDK&lt;/strong&gt; (&lt;code&gt;pio/&lt;/code&gt;): UART, I²C, PWM mejorado, DVI.&lt;/li&gt;
&lt;li&gt;Librerías comunitarias como &lt;strong&gt;rp2040-pio-emulator&lt;/strong&gt; para pruebas en PC.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.&lt;/p&gt;</description></item><item><title>Meshtastic explicado</title><link>https://ingeniummx.github.io/posts/comunicaciones/meshtastic-explicado/</link><pubDate>Sat, 16 Mar 2024 12:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/comunicaciones/meshtastic-explicado/</guid><description>&lt;p&gt;&lt;strong&gt;Meshtastic&lt;/strong&gt; es un firmware open source que transforma radios LoRa de bajo costo en redes malladas para mensajería y telemetría sin infraestructura celular. Es ideal para actividades al aire libre, resiliencia ante desastres y proyectos comunitarios.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-básica"&gt;Arquitectura básica&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Radios LoRa&lt;/strong&gt; basados en chip SX1262/SX1276 que operan en bandas ISM (433, 868, 915 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firmware Meshtastic&lt;/strong&gt; sobre microcontroladores ESP32, nRF52 o RP2040.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topología mesh&lt;/strong&gt;: cada nodo reenvía mensajes de manera asincrónica usando enrutamiento oportunista.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aplicaciones móviles&lt;/strong&gt; (Android/iOS) y clientes CLI/desktop que se conectan vía Bluetooth o USB.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="tipos-de-nodos"&gt;Tipos de nodos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Nodos personales:&lt;/strong&gt; dispositivos portátiles con pantalla (LilyGO T-Beam, T-Echo) que envían textos y ubicación GPS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nodos de infraestructura:&lt;/strong&gt; placas alimentadas continuamente para ampliar cobertura (antenas externas, alta potencia).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nodos sensores:&lt;/strong&gt; integran telemetría (temperatura, humedad, relés) y reportan periódicamente.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="configuración-inicial"&gt;Configuración inicial&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Instala el firmware con &lt;strong&gt;Meshtastic Flasher&lt;/strong&gt; o &lt;code&gt;meshtastic --flash&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Empareja el dispositivo con la app móvil mediante Bluetooth o USB.&lt;/li&gt;
&lt;li&gt;Ajusta &lt;strong&gt;canal, región y potencia&lt;/strong&gt; según normativa local (duty cycle, ERP).&lt;/li&gt;
&lt;li&gt;Define roles (router, client) y habilita características como MQTT bridge o almacenamiento en tarjeta SD.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="funciones-destacadas"&gt;Funciones destacadas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mensajería encriptada&lt;/strong&gt; con AES-CTR y claves compartidas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Posicionamiento GPS&lt;/strong&gt; y compartición de coordenadas con iconos personalizados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge MQTT/HTTP&lt;/strong&gt; para integrar con servidores o dashboards remotos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Telemetría extendida&lt;/strong&gt; a través de plugins Python (&lt;code&gt;meshtastic-python&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso"&gt;Casos de uso&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Equipos de senderismo, ciclismo o rescate que requieren comunicación sin cobertura celular.&lt;/li&gt;
&lt;li&gt;Redes comunitarias de alerta temprana (incendios, inundaciones).&lt;/li&gt;
&lt;li&gt;IoT rural con nodos alimentados por energía solar.&lt;/li&gt;
&lt;li&gt;Eventos temporales donde se necesita mensajería descentralizada.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="buenas-prácticas"&gt;Buenas prácticas&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Utiliza &lt;strong&gt;antenas calibradas&lt;/strong&gt; y respeta la polarización para maximizar alcance.&lt;/li&gt;
&lt;li&gt;Configura &lt;strong&gt;intervalos de retransmisión&lt;/strong&gt; adecuados para evitar congestión en mallas densas.&lt;/li&gt;
&lt;li&gt;Documenta &lt;strong&gt;claves y canales&lt;/strong&gt; en un gestor seguro para tu equipo.&lt;/li&gt;
&lt;li&gt;Mantén el firmware actualizado y participa en la comunidad de GitHub/Discord para aprovechar nuevas funciones.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con esta visión podrás planear una red Meshtastic confiable y adaptarla a tus necesidades de comunicación de largo alcance.&lt;/p&gt;</description></item><item><title>Herramientas indispensables para ROS 2</title><link>https://ingeniummx.github.io/posts/robotica/herramientas-indispensables-para-ros-2/</link><pubDate>Sat, 16 Mar 2024 12:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/robotica/herramientas-indispensables-para-ros-2/</guid><description>&lt;p&gt;ROS 2 ofrece múltiples utilidades para monitorear tópicos, analizar logs y depurar sistemas distribuidos. Conocer las herramientas correctas acelera el desarrollo y evita perder horas persiguiendo bugs.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="línea-de-comandos"&gt;Línea de comandos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ros2 topic&lt;/code&gt;&lt;/strong&gt;: inspecciona publicadores, suscriptores y contenido en tiempo real (&lt;code&gt;ros2 topic echo&lt;/code&gt;, &lt;code&gt;ros2 topic hz&lt;/code&gt;). Útil para validar tipos de mensajes y latencias.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ros2 node&lt;/code&gt;&lt;/strong&gt;: lista nodos activos, interfaces y parámetros expuestos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ros2 param&lt;/code&gt;&lt;/strong&gt;: permite leer/escribir parámetros dinámicos, ideal para ajustar PIDs o constantes sin recompilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ros2 bag&lt;/code&gt;&lt;/strong&gt;: registra y reproduce mensajes DDS para depuración offline o análisis de regresiones.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="visualización-3d-con-rviz"&gt;Visualización 3D con RViz&lt;/h2&gt;
&lt;p&gt;RViz es la navaja suiza para visualizar mapas, nubes de puntos y frames TF.&lt;/p&gt;</description></item><item><title>Elegir la ESP32 adecuada</title><link>https://ingeniummx.github.io/posts/microcontroladores/elegir-la-esp32-adecuada/</link><pubDate>Sat, 16 Mar 2024 11:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/elegir-la-esp32-adecuada/</guid><description>&lt;p&gt;La familia &lt;strong&gt;ESP32&lt;/strong&gt; de Espressif incluye docenas de variantes con diferentes radios, memoria y encapsulados. Escoger el módulo correcto evita limitaciones de memoria, consumo excesivo o falta de certificaciones inalámbricas.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="criterios-de-selección"&gt;Criterios de selección&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Conectividad inalámbrica.&lt;/strong&gt; ¿Necesitas Wi-Fi 2,4 GHz, Bluetooth LE, Classic o incluso 802.15.4?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria y almacenamiento.&lt;/strong&gt; Flash integrada (4–16 MB), PSRAM opcional para buffers gráficos o voz.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPIO disponibles.&lt;/strong&gt; Algunos módulos comparten pines con la antena o el cristal, reduciendo los I/O libres.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certificaciones.&lt;/strong&gt; Para productos finales busca módulos con FCC/CE y antena integrada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumo energético.&lt;/strong&gt; Evalúa modos de suspensión, corriente en deep sleep y voltaje operativo.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="variantes-populares"&gt;Variantes populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Módulo&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;RAM/Flash&lt;/th&gt;
&lt;th&gt;Radios&lt;/th&gt;
&lt;th&gt;Características clave&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-WROOM-32&lt;/td&gt;
&lt;td&gt;Xtensa LX6 dual a 240 MHz&lt;/td&gt;
&lt;td&gt;520 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT Classic/LE&lt;/td&gt;
&lt;td&gt;DevkitC, amplio soporte, antena PCB.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-WROVER&lt;/td&gt;
&lt;td&gt;Xtensa LX6 dual&lt;/td&gt;
&lt;td&gt;520 KB + 4 MB flash + 8 MB PSRAM&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT&lt;/td&gt;
&lt;td&gt;Ideal para gráficos, cámaras o SSL pesado.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-C3&lt;/td&gt;
&lt;td&gt;RISC-V single 160 MHz&lt;/td&gt;
&lt;td&gt;400 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT LE 5&lt;/td&gt;
&lt;td&gt;Bajo consumo, pin-to-pin con ESP8266.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-S3&lt;/td&gt;
&lt;td&gt;Xtensa LX7 dual 240 MHz&lt;/td&gt;
&lt;td&gt;512 KB + 8 MB flash/PSRAM&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT LE 5&lt;/td&gt;
&lt;td&gt;Vector instructions para IA, USB OTG.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-C6&lt;/td&gt;
&lt;td&gt;RISC-V single 160 MHz&lt;/td&gt;
&lt;td&gt;512 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi 6 + BT LE 5 + 802.15.4&lt;/td&gt;
&lt;td&gt;Thread/Matter listo, eficiente.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="devkits-recomendados"&gt;Devkits recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ESP32-DevKitC:&lt;/strong&gt; Referencia básica para WROOM. Incluye convertidor USB-UART y fácil acceso a pines.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP32-S3-DevKitC-1:&lt;/strong&gt; Para proyectos de visión gracias a USB nativo y soporte para cámaras.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP32-C3-DevKitM-1:&lt;/strong&gt; Ideal para wearables y sensores de baja potencia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LilyGO T-Display / T-Embed:&lt;/strong&gt; Añaden pantalla IPS, ranura microSD y batería LiPo integrada.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-prácticos"&gt;Consejos prácticos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Define primero la pila de software.&lt;/strong&gt; ESP-IDF, Arduino Core, MicroPython o circuitos con Matter pueden requerir memoria adicional.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Revisa el pinout oficial.&lt;/strong&gt; Algunos GPIO no toleran 5 V o están reservados para arranque (GPIO0, GPIO2, GPIO15).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Planea la antena.&lt;/strong&gt; Respeta el keep-out de la PCB o el conector U.FL para no degradar la potencia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aprovecha los modos de bajo consumo.&lt;/strong&gt; Configura RTC, ULP y wake-up por GPIO o temporizador para aplicaciones alimentadas por batería.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certifica tu producto.&lt;/strong&gt; Usa módulos pre-certificados y documenta las pruebas de radiofrecuencia.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con esta matriz podrás elegir el módulo ESP32 que mejor se ajuste a tu presupuesto, consumo y requisitos de conectividad.&lt;/p&gt;</description></item><item><title>Raspberry Pi Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</link><pubDate>Sat, 16 Mar 2024 11:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</guid><description>&lt;p&gt;La &lt;strong&gt;Raspberry Pi Pico&lt;/strong&gt; es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="especificaciones-esenciales"&gt;Especificaciones esenciales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microcontrolador:&lt;/strong&gt; RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria:&lt;/strong&gt; 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Periféricos:&lt;/strong&gt; 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación:&lt;/strong&gt; 1,8–5,5 V, regulador buck-boost integrado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos:&lt;/strong&gt; Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="fortalezas-del-rp2040"&gt;Fortalezas del RP2040&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PIO (Programmable I/O).&lt;/strong&gt; Motores de estado que permiten implementar protocolos personalizados a nivel de hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doble núcleo.&lt;/strong&gt; Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bajo costo y disponibilidad.&lt;/strong&gt; La placa base ronda los 4 USD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad y documentación amplia.&lt;/strong&gt; SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso-recomendados"&gt;Casos de uso recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controladores de robots educativos&lt;/strong&gt; gracias a su PWM abundante y soporte MicroPython.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces personalizadas&lt;/strong&gt; (DVI, VGA, audio PDM) mediante PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT económico&lt;/strong&gt; con el modelo Pico W y su módulo Wi-Fi CYW43439.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentos de laboratorio DIY&lt;/strong&gt; como generadores de señales y analizadores lógicos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-software"&gt;Ecosistema de software&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pico SDK (C/C++).&lt;/strong&gt; Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython y CircuitPython.&lt;/strong&gt; Repl inmediato, ideal para iterar rápido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TinyUSB.&lt;/strong&gt; Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bibliotecas de terceros.&lt;/strong&gt; Drivers para pantallas, sensores y motores mantenidos por la comunidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-proyectos"&gt;Consejos para proyectos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Usa el &lt;strong&gt;SMPS integrado&lt;/strong&gt; (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA.&lt;/li&gt;
&lt;li&gt;Aprovecha el &lt;strong&gt;debug por SWD&lt;/strong&gt; expuesto en los pads debajo de la placa.&lt;/li&gt;
&lt;li&gt;Para aplicaciones críticas, añade &lt;strong&gt;flash externa de calidad&lt;/strong&gt; y watchdog habilitado.&lt;/li&gt;
&lt;li&gt;Documenta la versión del SDK en tu repositorio para reproducibilidad.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.&lt;/p&gt;</description></item><item><title>Cómo escoger baterías</title><link>https://ingeniummx.github.io/posts/electronica/c%C3%B3mo-escoger-bater%C3%ADas/</link><pubDate>Sat, 16 Mar 2024 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/c%C3%B3mo-escoger-bater%C3%ADas/</guid><description>&lt;p&gt;Elegir la batería correcta evita apagones, sobrecalentamientos y ciclos de vida cortos. Esta guía resume las químicas más comunes, sus parámetros clave y criterios para combinarlas con tu electrónica.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="parámetros-críticos"&gt;Parámetros críticos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Voltaje nominal y rango operativo.&lt;/strong&gt; Asegúrate de que la tensión se mantenga dentro del margen de tu electrónica y reguladores.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capacidad (mAh o Wh).&lt;/strong&gt; Calcula el consumo promedio y el pico. Multiplica por el tiempo deseado y agrega un 20–30 % de margen.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capacidad de descarga (C-rate).&lt;/strong&gt; Determina la corriente máxima continua y en ráfagas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ciclo de vida.&lt;/strong&gt; Considera cuántos ciclos completos soporta antes de caer al 80 %.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temperatura y seguridad.&lt;/strong&gt; Verifica límites de operación y si necesitas circuitos de protección.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="tabla-comparativa"&gt;Tabla comparativa&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Química&lt;/th&gt;
&lt;th&gt;Voltaje por celda&lt;/th&gt;
&lt;th&gt;Densidad energética&lt;/th&gt;
&lt;th&gt;C-rate típica&lt;/th&gt;
&lt;th&gt;Puntos fuertes&lt;/th&gt;
&lt;th&gt;Precauciones&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LiPo (Li-ion polímero)&lt;/td&gt;
&lt;td&gt;3,7 V (2,7–4,2 V)&lt;/td&gt;
&lt;td&gt;Muy alta&lt;/td&gt;
&lt;td&gt;1C–35C&lt;/td&gt;
&lt;td&gt;Ligera, entrega altas corrientes.&lt;/td&gt;
&lt;td&gt;Necesita balanceo y protección contra sobrecarga/descarga.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LiFePO₄&lt;/td&gt;
&lt;td&gt;3,2 V (2,5–3,6 V)&lt;/td&gt;
&lt;td&gt;Media&lt;/td&gt;
&lt;td&gt;1C–5C&lt;/td&gt;
&lt;td&gt;Segura, &amp;gt;2000 ciclos, estable térmicamente.&lt;/td&gt;
&lt;td&gt;Voltaje por celda menor, requiere más celdas en serie.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Plomo-ácido (SLA, AGM)&lt;/td&gt;
&lt;td&gt;2,0 V (1,8–2,4 V)&lt;/td&gt;
&lt;td&gt;Baja&lt;/td&gt;
&lt;td&gt;0,2C–1C&lt;/td&gt;
&lt;td&gt;Económica, disponible en altos Ah.&lt;/td&gt;
&lt;td&gt;Pesada, no tolera descargas profundas continuas.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NiMH&lt;/td&gt;
&lt;td&gt;1,2 V (1,0–1,4 V)&lt;/td&gt;
&lt;td&gt;Media&lt;/td&gt;
&lt;td&gt;0,5C–5C&lt;/td&gt;
&lt;td&gt;Robusta, fácil de cargar.&lt;/td&gt;
&lt;td&gt;Autodescarga alta, requiere cargador inteligente.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;18650 Li-ion&lt;/td&gt;
&lt;td&gt;3,6 V (2,5–4,2 V)&lt;/td&gt;
&lt;td&gt;Muy alta&lt;/td&gt;
&lt;td&gt;1C–10C&lt;/td&gt;
&lt;td&gt;Modular, buena densidad.&lt;/td&gt;
&lt;td&gt;Igual que LiPo: protección obligatoria.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="seleccionar-el-formato"&gt;Seleccionar el formato&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Drones y robótica móvil:&lt;/strong&gt; LiPo por su alta potencia instantánea. Incluye monitorización individual de celdas y bolsas ignífugas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT estacionario o respaldo:&lt;/strong&gt; LiFePO₄ por seguridad y longevidad. Combina con BMS y cargador CC/CV dedicado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prototipos económicos:&lt;/strong&gt; Pack de NiMH AA recargables o SLA pequeño. Aceptan maltrato y son fáciles de encontrar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aplicaciones industriales 24/7:&lt;/strong&gt; LiFePO₄ o Li-ion con celdas 18650 de calidad, gestionadas con BMS redundante y telemetría.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="gestión-y-protección"&gt;Gestión y protección&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Incluye un BMS adecuado.&lt;/strong&gt; Asegura balanceo, corte por sobrecorriente y protección térmica.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dimensiona el cargador.&lt;/strong&gt; La corriente recomendada suele ser 0,5C para LiPo/Li-ion y 0,3C para LiFePO₄.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Regulación de voltaje.&lt;/strong&gt; Usa convertidores buck/boost para entregar tensiones estables a tu circuito.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plan de almacenamiento.&lt;/strong&gt; LiPo al 40–60 % y en bolsas ignífugas; plomo-ácido siempre cargadas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monitoreo en campo.&lt;/strong&gt; Integra medidores de coulomb, estimación de SoC y alarmas de temperatura.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="checklist-rápido"&gt;Checklist rápido&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; ¿La química soporta la corriente pico de tu carga?&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; ¿Tu BMS controla temperatura, balance y sobrecarga?&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; ¿El cargador respeta curvas CC/CV o delta-peak según la química?&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; ¿La caja o chasis incluye ventilación y protección mecánica?&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; ¿Documentaste procedimiento de transporte y reciclaje?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con estos pasos podrás seleccionar una batería que equilibre seguridad, autonomía y costo sin sorpresas en el laboratorio ni en campo.&lt;/p&gt;</description></item><item><title>Pull-up vs pull-down</title><link>https://ingeniummx.github.io/posts/electronica/pull-up-vs-pull-down/</link><pubDate>Sat, 16 Mar 2024 09:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/pull-up-vs-pull-down/</guid><description>&lt;p&gt;Las entradas digitales en microcontroladores, FPGAs o sensores necesitan una referencia estable de nivel lógico cuando el pulsador o dispositivo externo está abierto. Para lograrlo usamos &lt;strong&gt;resistencias pull-up y pull-down&lt;/strong&gt;. Saber cuándo elegir cada una evita lecturas erráticas y consumo innecesario.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="qué-hace-una-resistencia-pull-up"&gt;Qué hace una resistencia pull-up&lt;/h2&gt;
&lt;p&gt;Una &lt;strong&gt;pull-up&lt;/strong&gt; conecta la entrada a (V_{CC}) mediante una resistencia. Cuando el botón está abierto la entrada lee un &amp;ldquo;1&amp;rdquo; lógico; al cerrar el contacto hacia tierra, la corriente fluye a través de la resistencia y el nodo cae a &amp;ldquo;0&amp;rdquo;.&lt;/p&gt;</description></item><item><title>¿Qué es un motor a pasos y cómo aprovecharlo?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-motor-a-pasos-y-c%C3%B3mo-aprovecharlo/</link><pubDate>Fri, 15 Mar 2024 09:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-motor-a-pasos-y-c%C3%B3mo-aprovecharlo/</guid><description>&lt;p&gt;Los &lt;strong&gt;motores a pasos&lt;/strong&gt; (stepper motors) convierten pulsos eléctricos en &lt;strong&gt;movimientos angulares discretos&lt;/strong&gt;. En cada paso el eje gira un ángulo fijo (1,8°, 0,9°, etc.), por lo que podemos posicionar cargas sin retroalimentación mecánica adicional.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="cómo-funciona-un-motor-a-pasos"&gt;¿Cómo funciona un motor a pasos?&lt;/h2&gt;
&lt;p&gt;Un motor a pasos típico tiene:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Estator&lt;/strong&gt; con varias bobinas agrupadas en fases.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rotor&lt;/strong&gt; dentado con imanes permanentes o material ferroso.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Secuencia de excitación&lt;/strong&gt;: aplicar corriente a las bobinas en un orden preciso genera un campo magnético rotatorio que “arrastra” al rotor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cada vez que cambiamos la fase energizada el rotor avanza un &lt;strong&gt;paso&lt;/strong&gt;. Si completamos (N) pasos obtenemos una vuelta completa, y podemos calcular los pasos por vuelta como:&lt;/p&gt;</description></item></channel></rss>