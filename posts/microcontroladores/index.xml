<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Microcontroladores on Ingenium MX</title><link>https://ingeniummx.github.io/posts/microcontroladores/</link><description>Recent content in Microcontroladores on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://ingeniummx.github.io/posts/microcontroladores/index.xml" rel="self" type="application/rss+xml"/><item><title>Cómo elegir el módulo ESP32 ideal para tu PCB</title><link>https://ingeniummx.github.io/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/</link><pubDate>Wed, 05 Jun 2024 10:00:00 -0600</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/c%C3%B3mo-elegir-el-m%C3%B3dulo-esp32-ideal-para-tu-pcb/</guid><description>&lt;h1 id="cómo-elegir-el-módulo-esp32-ideal-para-tu-pcb"&gt;Cómo elegir el módulo ESP32 ideal para tu PCB&lt;/h1&gt;
&lt;p&gt;La familia ESP32 es estándar en IoT por costo, Wi-Fi/BLE y ecosistema. Al pasar de prototipo a producto, la elección del &lt;strong&gt;módulo&lt;/strong&gt; impacta RF, consumo, certificación y BOM. Esta guía resume criterios &lt;strong&gt;técnicos, regulatorios y logísticos&lt;/strong&gt; para seleccionar con confianza.&lt;/p&gt;
&lt;h2 id="1-define-requisitos-del-producto"&gt;1) Define requisitos del producto&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Energía y consumo.&lt;/strong&gt; ¿Batería o línea? Filtra por &lt;em&gt;deep sleep&lt;/em&gt; (≈5 µA en C3 hasta &amp;gt;20 µA en S3) y por picos de TX (500–700 mA).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conectividad.&lt;/strong&gt; Además de Wi-Fi 2.4 GHz, hay BLE 5.x (C3/S3), 802.15.4 para Thread/Matter (C6), e incluso variantes sin Wi-Fi (H2). Elige primero la &lt;strong&gt;familia&lt;/strong&gt; por protocolo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria y periféricos.&lt;/strong&gt; TLS pesado, UI, voz/visión → &lt;strong&gt;PSRAM&lt;/strong&gt; + más flash (p.ej., WROVER, S3 8–16 MB). Sensores simples → 2–4 MB.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entorno.&lt;/strong&gt; Rango de temperatura, blindaje metálico y robustez EMI (p.ej., WROOM-32E/UE). Verifica versiones industriales.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-elige-la-familia-esp32"&gt;2) Elige la familia ESP32&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Familia&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Radios&lt;/th&gt;
&lt;th&gt;Ventajas&lt;/th&gt;
&lt;th&gt;Casos típicos&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32 (WROOM/WROVER)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Xtensa LX6&lt;/td&gt;
&lt;td&gt;Wi-Fi b/g/n, BT Classic + LE&lt;/td&gt;
&lt;td&gt;Ecosistema maduro, opciones con PSRAM&lt;/td&gt;
&lt;td&gt;Gateways, audio, TFT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-S2/S3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Xtensa (S3 con SIMD)&lt;/td&gt;
&lt;td&gt;Wi-Fi (S3: + BLE)&lt;/td&gt;
&lt;td&gt;USB OTG, aceleraciones para IA&lt;/td&gt;
&lt;td&gt;HID, cámaras/LCD, edge-AI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-C2/C3/C6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RISC-V&lt;/td&gt;
&lt;td&gt;C3: Wi-Fi + BLE; C6: + 802.15.4&lt;/td&gt;
&lt;td&gt;Bajo consumo, Matter/Thread&lt;/td&gt;
&lt;td&gt;Batería, domótica&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ESP32-H2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RISC-V&lt;/td&gt;
&lt;td&gt;BLE + 802.15.4&lt;/td&gt;
&lt;td&gt;Ultra bajo consumo, sin Wi-Fi&lt;/td&gt;
&lt;td&gt;Zigbee/Thread con pila&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Primero &lt;strong&gt;familia por protocolo/consumo&lt;/strong&gt;; luego la &lt;strong&gt;variante&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>Instalar micro-ROS en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 18:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/instalar-micro-ros-en-la-pico/</guid><description>&lt;p&gt;&lt;strong&gt;micro-ROS&lt;/strong&gt; lleva ROS 2 a microcontroladores con recursos limitados. A continuación se describe cómo configurar el build system para la Raspberry Pi Pico utilizando el Pico SDK oficial.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="prerrequisitos"&gt;Prerrequisitos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Toolchain Arm (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt;), CMake y Ninja.&lt;/li&gt;
&lt;li&gt;ROS 2 Humble (o posterior) instalado en tu sistema.&lt;/li&gt;
&lt;li&gt;Repositorio &lt;code&gt;micro_ros_setup&lt;/code&gt; clonado en el workspace de ROS 2.&lt;/li&gt;
&lt;li&gt;Pico SDK inicializado (&lt;code&gt;PICO_SDK_PATH&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="configurar-el-workspace"&gt;Configurar el workspace&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source /opt/ros/humble/setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ~/micro_ros_ws/src
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/micro-ROS/micro_ros_setup.git
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ..
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;colcon build
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;source install/local_setup.bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="crear-firmware-para-la-pico"&gt;Crear firmware para la Pico&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Importa los repositorios necesarios&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup create_firmware_ws.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;Descarga dependencias&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup configure_firmware.sh freertos raspberripi_pico
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;Compila&lt;/strong&gt; con opciones personalizadas (Wi-Fi deshabilitada por defecto):&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ros2 run micro_ros_setup build_firmware.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="4"&gt;
&lt;li&gt;El resultado (&lt;code&gt;firmware.uf2&lt;/code&gt;) se genera en &lt;code&gt;firmware/build&lt;/code&gt;. Cópialo a la Pico en modo BOOTSEL.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-nodo-ping"&gt;Ejemplo: nodo ping&lt;/h2&gt;
&lt;p&gt;Tras flashear, conecta la Pico por USB y ejecuta en el host:&lt;/p&gt;</description></item><item><title>Ampliar entradas digitales con I2C</title><link>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</link><pubDate>Sat, 16 Mar 2024 18:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/</guid><description>&lt;p&gt;Cuando el número de GPIO de la Raspberry Pi Pico no basta, puedes &lt;strong&gt;ampliar entradas digitales&lt;/strong&gt; con expansores I2C. Estos integrados entregan 8, 16 o más pines configurables sin sacrificar recursos del microcontrolador.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="expansores-populares"&gt;Expansores populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chip&lt;/th&gt;
&lt;th&gt;Bits&lt;/th&gt;
&lt;th&gt;Voltaje&lt;/th&gt;
&lt;th&gt;Características&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MCP23017&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;1,8–5,5 V&lt;/td&gt;
&lt;td&gt;Dos bancos de 8 bits, interrupciones configurables, pull-ups internos.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PCF8575&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–5,5 V&lt;/td&gt;
&lt;td&gt;Entradas/salidas quasi-bidireccionales, ideal para lectura de botones.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCA9555&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,3–5,5 V&lt;/td&gt;
&lt;td&gt;Interrupciones separadas, compatible con 400 kHz.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SX1509&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2,5–3,6 V&lt;/td&gt;
&lt;td&gt;PWM por pin, debounce interno y lógica de interrupciones avanzada.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="conexión-básica"&gt;Conexión básica&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Conecta SDA y SCL al bus I2C de la Pico (GPIO 4 y 5 por defecto) con &lt;strong&gt;pull-ups de 4,7 kΩ&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Alimenta el expansor con 3,3 V o el voltaje requerido.&lt;/li&gt;
&lt;li&gt;Configura las direcciones mediante pines A0-A2.&lt;/li&gt;
&lt;li&gt;Conecta pines de interrupción (INTA/INTB) a GPIO disponibles para detectar cambios sin sondeo constante.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplo-con-mcp23017-en-micropython"&gt;Ejemplo con MCP23017 en MicroPython&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; machine &lt;span style="color:#f92672"&gt;import&lt;/span&gt; I2C, Pin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; mcp23017 &lt;span style="color:#f92672"&gt;import&lt;/span&gt; MCP23017
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;i2c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; I2C(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, scl&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;), sda&lt;span style="color:#f92672"&gt;=&lt;/span&gt;Pin(&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;), freq&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;400000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp &lt;span style="color:#f92672"&gt;=&lt;/span&gt; MCP23017(i2c, address&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0x20&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;setup(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, MCP23017&lt;span style="color:#f92672"&gt;.&lt;/span&gt;IN, pullup&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado0 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; estado1 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; exp&lt;span style="color:#f92672"&gt;.&lt;/span&gt;input(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;# Procesa botones&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;En C/C++ utiliza la librería &lt;code&gt;hardware/i2c.h&lt;/code&gt; y escribe a los registros &lt;code&gt;IODIRA&lt;/code&gt;, &lt;code&gt;GPPUA&lt;/code&gt; y &lt;code&gt;GPIOA&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Programar la Pico en C++</title><link>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</link><pubDate>Sat, 16 Mar 2024 13:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/programar-la-pico-en-c-/</guid><description>&lt;p&gt;Programar la Raspberry Pi Pico directamente en C/C++ ofrece máximo control sobre el hardware y mejor desempeño que las capas de compatibilidad Arduino. Estos son los pasos clave para configurar el entorno oficial &lt;strong&gt;Pico SDK&lt;/strong&gt; en Windows, Linux o macOS.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="requisitos-previos"&gt;Requisitos previos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Toolchain Arm GCC&lt;/strong&gt; (&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; y &lt;code&gt;newlib&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMake ≥ 3.13&lt;/strong&gt; y &lt;strong&gt;Ninja&lt;/strong&gt; o Make.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 3&lt;/strong&gt; para scripts auxiliares.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt; para clonar el SDK y submódulos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En Windows se recomienda usar &lt;strong&gt;WSL&lt;/strong&gt; o el instalador oficial que empaqueta todas las dependencias.&lt;/p&gt;</description></item><item><title>Módulos PIO en la Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</link><pubDate>Sat, 16 Mar 2024 13:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/</guid><description>&lt;p&gt;Los &lt;strong&gt;módulos PIO (Programmable I/O)&lt;/strong&gt; del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-pio"&gt;Arquitectura PIO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Máquinas de estado:&lt;/strong&gt; hasta 4 por bloque, cada una con 32 instrucciones de 16 bits.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO TX/RX:&lt;/strong&gt; buffers de 4 palabras para intercambio con la CPU o DMA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins flexibles:&lt;/strong&gt; mapeo independiente para entrada, salida y side-set.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock divider:&lt;/strong&gt; ajusta la frecuencia de ejecución con resolución fraccional.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="flujo-de-trabajo"&gt;Flujo de trabajo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Escribe el programa PIO en ensamblador específico (&lt;code&gt;.program&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Carga el código en la instrucción memory del bloque PIO.&lt;/li&gt;
&lt;li&gt;Configura los registros de control (SM, clocks, pins).&lt;/li&gt;
&lt;li&gt;Usa la API del SDK o MicroPython para enviar/recibir datos.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="ejemplos-prácticos"&gt;Ejemplos prácticos&lt;/h2&gt;
&lt;h3 id="ws2812-neopixel"&gt;WS2812 (NeoPixel)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Genera los pulsos de 800 kHz con side-set para controlar tiras RGB.&lt;/li&gt;
&lt;li&gt;Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interfaces-vgadvi"&gt;Interfaces VGA/DVI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas.&lt;/li&gt;
&lt;li&gt;Requiere DMA para alimentar los buffers a alta velocidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="captura-de-señales"&gt;Captura de señales&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Configura una máquina PIO en modo &lt;code&gt;IN&lt;/code&gt; para muestrear pines a alta frecuencia.&lt;/li&gt;
&lt;li&gt;Vuelca los datos a memoria mediante DMA para análisis posterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-de-implementación"&gt;Consejos de implementación&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Planifica el ancho de palabra.&lt;/strong&gt; Ajusta &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt; y shift registers para empaquetar datos eficientemente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Utiliza DMA.&lt;/strong&gt; Mantiene alimentadas las FIFOs sin bloquear la CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Divide funciones entre máquinas.&lt;/strong&gt; Un bloque puede generar reloj y otro manejar datos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura con &lt;code&gt;pioasm&lt;/code&gt;.&lt;/strong&gt; El SDK incluye herramientas para validar el programa antes de compilar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sincroniza con IRQ.&lt;/strong&gt; Usa interrupciones PIO para coordinar eventos con el firmware principal.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="recursos-adicionales"&gt;Recursos adicionales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Documentación oficial del &lt;strong&gt;RP2040 Datasheet&lt;/strong&gt; (capítulo PIO).&lt;/li&gt;
&lt;li&gt;Ejemplos del &lt;strong&gt;Pico SDK&lt;/strong&gt; (&lt;code&gt;pio/&lt;/code&gt;): UART, I²C, PWM mejorado, DVI.&lt;/li&gt;
&lt;li&gt;Librerías comunitarias como &lt;strong&gt;rp2040-pio-emulator&lt;/strong&gt; para pruebas en PC.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.&lt;/p&gt;</description></item><item><title>Elegir la ESP32 adecuada</title><link>https://ingeniummx.github.io/posts/microcontroladores/elegir-la-esp32-adecuada/</link><pubDate>Sat, 16 Mar 2024 11:30:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/elegir-la-esp32-adecuada/</guid><description>&lt;p&gt;La familia &lt;strong&gt;ESP32&lt;/strong&gt; de Espressif incluye docenas de variantes con diferentes radios, memoria y encapsulados. Escoger el módulo correcto evita limitaciones de memoria, consumo excesivo o falta de certificaciones inalámbricas.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="criterios-de-selección"&gt;Criterios de selección&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Conectividad inalámbrica.&lt;/strong&gt; ¿Necesitas Wi-Fi 2,4 GHz, Bluetooth LE, Classic o incluso 802.15.4?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria y almacenamiento.&lt;/strong&gt; Flash integrada (4–16 MB), PSRAM opcional para buffers gráficos o voz.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPIO disponibles.&lt;/strong&gt; Algunos módulos comparten pines con la antena o el cristal, reduciendo los I/O libres.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certificaciones.&lt;/strong&gt; Para productos finales busca módulos con FCC/CE y antena integrada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumo energético.&lt;/strong&gt; Evalúa modos de suspensión, corriente en deep sleep y voltaje operativo.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="variantes-populares"&gt;Variantes populares&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Módulo&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;RAM/Flash&lt;/th&gt;
&lt;th&gt;Radios&lt;/th&gt;
&lt;th&gt;Características clave&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-WROOM-32&lt;/td&gt;
&lt;td&gt;Xtensa LX6 dual a 240 MHz&lt;/td&gt;
&lt;td&gt;520 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT Classic/LE&lt;/td&gt;
&lt;td&gt;DevkitC, amplio soporte, antena PCB.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-WROVER&lt;/td&gt;
&lt;td&gt;Xtensa LX6 dual&lt;/td&gt;
&lt;td&gt;520 KB + 4 MB flash + 8 MB PSRAM&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT&lt;/td&gt;
&lt;td&gt;Ideal para gráficos, cámaras o SSL pesado.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-C3&lt;/td&gt;
&lt;td&gt;RISC-V single 160 MHz&lt;/td&gt;
&lt;td&gt;400 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT LE 5&lt;/td&gt;
&lt;td&gt;Bajo consumo, pin-to-pin con ESP8266.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-S3&lt;/td&gt;
&lt;td&gt;Xtensa LX7 dual 240 MHz&lt;/td&gt;
&lt;td&gt;512 KB + 8 MB flash/PSRAM&lt;/td&gt;
&lt;td&gt;Wi-Fi + BT LE 5&lt;/td&gt;
&lt;td&gt;Vector instructions para IA, USB OTG.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP32-C6&lt;/td&gt;
&lt;td&gt;RISC-V single 160 MHz&lt;/td&gt;
&lt;td&gt;512 KB + 4 MB flash&lt;/td&gt;
&lt;td&gt;Wi-Fi 6 + BT LE 5 + 802.15.4&lt;/td&gt;
&lt;td&gt;Thread/Matter listo, eficiente.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="devkits-recomendados"&gt;Devkits recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ESP32-DevKitC:&lt;/strong&gt; Referencia básica para WROOM. Incluye convertidor USB-UART y fácil acceso a pines.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP32-S3-DevKitC-1:&lt;/strong&gt; Para proyectos de visión gracias a USB nativo y soporte para cámaras.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP32-C3-DevKitM-1:&lt;/strong&gt; Ideal para wearables y sensores de baja potencia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LilyGO T-Display / T-Embed:&lt;/strong&gt; Añaden pantalla IPS, ranura microSD y batería LiPo integrada.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-prácticos"&gt;Consejos prácticos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Define primero la pila de software.&lt;/strong&gt; ESP-IDF, Arduino Core, MicroPython o circuitos con Matter pueden requerir memoria adicional.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Revisa el pinout oficial.&lt;/strong&gt; Algunos GPIO no toleran 5 V o están reservados para arranque (GPIO0, GPIO2, GPIO15).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Planea la antena.&lt;/strong&gt; Respeta el keep-out de la PCB o el conector U.FL para no degradar la potencia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aprovecha los modos de bajo consumo.&lt;/strong&gt; Configura RTC, ULP y wake-up por GPIO o temporizador para aplicaciones alimentadas por batería.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certifica tu producto.&lt;/strong&gt; Usa módulos pre-certificados y documenta las pruebas de radiofrecuencia.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con esta matriz podrás elegir el módulo ESP32 que mejor se ajuste a tu presupuesto, consumo y requisitos de conectividad.&lt;/p&gt;</description></item><item><title>Raspberry Pi Pico</title><link>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</link><pubDate>Sat, 16 Mar 2024 11:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/microcontroladores/raspberry-pi-pico/</guid><description>&lt;p&gt;La &lt;strong&gt;Raspberry Pi Pico&lt;/strong&gt; es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="especificaciones-esenciales"&gt;Especificaciones esenciales&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Microcontrolador:&lt;/strong&gt; RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria:&lt;/strong&gt; 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Periféricos:&lt;/strong&gt; 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alimentación:&lt;/strong&gt; 1,8–5,5 V, regulador buck-boost integrado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos:&lt;/strong&gt; Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="fortalezas-del-rp2040"&gt;Fortalezas del RP2040&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PIO (Programmable I/O).&lt;/strong&gt; Motores de estado que permiten implementar protocolos personalizados a nivel de hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doble núcleo.&lt;/strong&gt; Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bajo costo y disponibilidad.&lt;/strong&gt; La placa base ronda los 4 USD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunidad y documentación amplia.&lt;/strong&gt; SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="casos-de-uso-recomendados"&gt;Casos de uso recomendados&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controladores de robots educativos&lt;/strong&gt; gracias a su PWM abundante y soporte MicroPython.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interfaces personalizadas&lt;/strong&gt; (DVI, VGA, audio PDM) mediante PIO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT económico&lt;/strong&gt; con el modelo Pico W y su módulo Wi-Fi CYW43439.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instrumentos de laboratorio DIY&lt;/strong&gt; como generadores de señales y analizadores lógicos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="ecosistema-de-software"&gt;Ecosistema de software&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pico SDK (C/C++).&lt;/strong&gt; Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython y CircuitPython.&lt;/strong&gt; Repl inmediato, ideal para iterar rápido.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TinyUSB.&lt;/strong&gt; Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bibliotecas de terceros.&lt;/strong&gt; Drivers para pantallas, sensores y motores mantenidos por la comunidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="consejos-para-proyectos"&gt;Consejos para proyectos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Usa el &lt;strong&gt;SMPS integrado&lt;/strong&gt; (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA.&lt;/li&gt;
&lt;li&gt;Aprovecha el &lt;strong&gt;debug por SWD&lt;/strong&gt; expuesto en los pads debajo de la placa.&lt;/li&gt;
&lt;li&gt;Para aplicaciones críticas, añade &lt;strong&gt;flash externa de calidad&lt;/strong&gt; y watchdog habilitado.&lt;/li&gt;
&lt;li&gt;Documenta la versión del SDK en tu repositorio para reproducibilidad.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.&lt;/p&gt;</description></item></channel></rss>