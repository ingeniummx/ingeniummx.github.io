<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Ingenium MX</title><link>https://ingeniummx.github.io/posts/</link><description>Recent content in Posts on Ingenium MX</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://ingeniummx.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>¿Qué es MQTT y por qué se usa tanto en IoT?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/</link><pubDate>Thu, 18 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/</guid><description>&lt;p&gt;El &lt;strong&gt;protocolo MQTT (Message Queuing Telemetry Transport)&lt;/strong&gt; se ha convertido en el &lt;em&gt;idioma común&lt;/em&gt; de los proyectos &lt;strong&gt;IoT&lt;/strong&gt;, tanto domésticos como industriales. Es &lt;strong&gt;ligero&lt;/strong&gt;, funciona bien con enlaces inestables y permite que sensores, microcontroladores, dashboards y servicios en la nube intercambien datos sin enredarse en sockets manuales. Su modelo &lt;strong&gt;publish/subscribe&lt;/strong&gt; gira alrededor de un broker que recibe, filtra y entrega mensajes, de los clientes que publican o se suscriben, y de los temas (&lt;em&gt;topics&lt;/em&gt;) que organizan la información con rutas jerárquicas como &lt;code&gt;ingenium/sala/temperatura&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Puente H con relevadores: controla un motor DC con Arduino</title><link>https://ingeniummx.github.io/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/</link><pubDate>Tue, 16 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/</guid><description>&lt;p&gt;Un &lt;strong&gt;puente H&lt;/strong&gt; es un circuito que permite invertir el sentido de giro de un motor de corriente directa (DC) al cambiar la polaridad de alimentación entre sus terminales. Se utiliza en aplicaciones donde es necesario controlar el movimiento en ambos sentidos, como en robótica o mecanismos reversibles.&lt;/p&gt;
&lt;p&gt;En este proyecto vamos a construir un puente H sencillo utilizando un &lt;strong&gt;módulo de 2 relevadores de 5 V&lt;/strong&gt;, muy común en kits de Arduino, para controlar un motor DC de 12 V.&lt;/p&gt;</description></item><item><title>Cómo instalar Ubuntu 24.04 en Windows 11 con WSL2 paso a paso</title><link>https://ingeniummx.github.io/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/</link><pubDate>Mon, 15 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/</guid><description>&lt;p&gt;El &lt;strong&gt;Subsistema de Windows para Linux (WSL2)&lt;/strong&gt; permite correr distribuciones de Linux dentro de Windows 11, sin necesidad de crear una máquina virtual con VirtualBox ni instalar dual-boot.&lt;br&gt;
En este tutorial instalaremos &lt;strong&gt;Ubuntu 24.04 (Noble Numbat)&lt;/strong&gt;, configuraremos aplicaciones esenciales como &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;gedit&lt;/code&gt;, y prepararemos el entorno para trabajar con &lt;strong&gt;Visual Studio Code&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="1-wsl2-en-windows-11"&gt;1. WSL2 en Windows 11&lt;/h2&gt;
&lt;p&gt;Abre &lt;strong&gt;PowerShell como administrador&lt;/strong&gt; y ejecuta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-powershell" data-lang="powershell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dism.exe /online /enable-feature /featurename&lt;span style="color:#960050;background-color:#1e0010"&gt;:&lt;/span&gt;Microsoft-Windows-Subsystem-Linux /all /norestart
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dism.exe /online /enable-feature /featurename&lt;span style="color:#960050;background-color:#1e0010"&gt;:&lt;/span&gt;VirtualMachinePlatform /all /norestart
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Reinicia el equipo y verifica que WSL2 está activo:&lt;/p&gt;</description></item><item><title>¿Qué es un circuito antirrebote?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/</link><pubDate>Tue, 09 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/</guid><description>&lt;p&gt;Los &lt;strong&gt;pulsadores&lt;/strong&gt;, &lt;strong&gt;switches&lt;/strong&gt; y &lt;strong&gt;relés&lt;/strong&gt; están en todos lados.&lt;br&gt;
Cuando los conectamos a un microcontrolador (PIC, ESP32, Arduino, etc.) esperamos un &lt;strong&gt;cambio de estado limpio&lt;/strong&gt; por cada pulsación. En la práctica no ocurre así: los contactos mecánicos &lt;strong&gt;rebotan&lt;/strong&gt; durante unos milisegundos y generan &lt;strong&gt;varias transiciones&lt;/strong&gt; antes de estabilizarse. A esto se le llama &lt;strong&gt;rebote de contacto&lt;/strong&gt; (&lt;em&gt;contact bounce&lt;/em&gt;).&lt;/p&gt;
&lt;div style="text-align:center; margin: 1em 0;"&gt;
&lt;div style="border:2px dashed #bbb; padding:28px; width:80%; height:220px; margin:0 auto; display:flex; align-items:center; justify-content:center; color:#777;"&gt;
&lt;strong&gt;PLACEHOLDER IMG:&lt;/strong&gt;&amp;nbsp; "button-ideal-vs-bounce.png" — Señal ideal vs con rebote
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Ideal vs. real: sin rebote (arriba) vs. con rebote (abajo)&lt;/em&gt;&lt;/p&gt;</description></item><item><title>¿Qué es una PCB y cómo mandarlas a hacer?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/</link><pubDate>Mon, 08 Sep 2025 10:00:00 +0200</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/</guid><description>&lt;p&gt;Si alguna vez has desarmado un dispositivo electrónico, seguramente te has encontrado con placas verdes o azules con componentes electrónicos.&lt;/p&gt;
&lt;p&gt;El acrónimo &lt;strong&gt;PCB&lt;/strong&gt; viene del inglés &lt;em&gt;Printed Circuit Board&lt;/em&gt; y se traduce como &lt;strong&gt;placa de circuito impreso&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;En pocas palabras, una PCB es una &lt;strong&gt;placa de fibra con pistas de cobre&lt;/strong&gt;. Estas pistas son cables planos que conectan los componentes entre sí de manera ordenada y confiable.&lt;/p&gt;
&lt;p&gt;Un PCB está formado por varias capas físicas:&lt;/p&gt;</description></item><item><title>¿Qué es OPC UA y por qué es clave en la automatización industrial?</title><link>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/</link><pubDate>Fri, 14 Feb 2025 09:00:00 -0600</pubDate><guid>https://ingeniummx.github.io/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/</guid><description>&lt;p&gt;El estándar &lt;strong&gt;OPC UA (Open Platform Communications Unified Architecture)&lt;/strong&gt; es la evolución más robusta de la familia OPC. Fue diseñado para llevar los datos de máquinas, sensores y sistemas SCADA a aplicaciones empresariales o servicios en la nube sin depender de software propietario. Su propuesta combina un &lt;strong&gt;modelo de información semántico&lt;/strong&gt;, comunicaciones &lt;strong&gt;orientadas a servicios&lt;/strong&gt; y &lt;strong&gt;seguridad de grado industrial&lt;/strong&gt; en una sola especificación.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="arquitectura-por-capas-más-allá-del-simple-cliente-servidor"&gt;Arquitectura por capas: más allá del simple cliente-servidor&lt;/h2&gt;
&lt;p&gt;A primera vista, OPC UA sigue un modelo cliente-servidor: los &lt;strong&gt;servidores&lt;/strong&gt; exponen datos y métodos provenientes de dispositivos u otras fuentes, mientras que los &lt;strong&gt;clientes&lt;/strong&gt; consumen esa información. Sin embargo, bajo la superficie hay una pila organizada en capas que separa transporte, codificación y servicios para lograr interoperabilidad real.&lt;/p&gt;</description></item></channel></rss>