<!doctype html><html lang=es><head><title>Posts</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="Ingenium MX"><meta name=keywords content="ingeniería,mecatrónica,robótica,electrónica,programación,maker,tutoriales"><link rel=stylesheet href=/application.f903a84a4d6cdf391a9c73c052bdad738f02d47ae2885f2dc6791d63bff5750d.css integrity="sha256-+QOoSk1s3zkanHPAUr2tc48C1HriiF8txnkdY7/1dQ0="><link rel=icon type=image/png href=/images/site/favicon_hu_f8052c7b59e526d6.png><link rel=alternate type=application/rss+xml href=https://ingeniummx.github.io/posts/index.xml title="Ingenium MX"><meta property="og:title" content="Ingenium Mx – Aprende, construye, crea"><meta property="og:type" content="website"><meta property="og:description" content="Ingenium Mx – Aprende, construye, crea. Comunidad de innovación en ingeniería, tecnología, mecatrónica, robótica, electrónica, programación y ciencia."><meta property="og:image" content="/images/author/logo.png"><meta property="og:url" content="https://ingeniummx.github.io"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Ingenium MX"><meta name=twitter:description content="Ingenium Mx – Aprende, construye, crea. Un espacio dedicado a proyectos de ingeniería, ciencia, tecnología, mecatrónica, robótica, electrónica, programación."><meta name=twitter:image content="/images/author/logo2.png"><meta name=twitter:url content="https://ingeniummx.github.io/"><meta name=twitter:site content="@ingeniummx"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","url":"https:\/\/ingeniummx.github.io\/","name":"Ingenium MX","description":"","publisher":{"@type":"Organization","name":"Ingenium MX","logo":{"@type":"ImageObject","url":"https:\/\/ingeniummx.github.io\/images\/author\/logo3.png"}},"inLanguage":"es"}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2537780317928465" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-09PLHGV7MZ"></script><script>var dnt,doNotTrack=!1;if(null&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-09PLHGV7MZ")}</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","tb58j7pbqy")</script><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-section" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/main-logo_hu_f8052c7b59e526d6.png id=logo alt=Logo>
Ingenium MX</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Inicio</a></li><li class=nav-item><a class=nav-link href=/#about>Acerca de</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>Posts</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Blog</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=languageSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><span class="fi fi-es"></span>
Español</a><div class=dropdown-menu aria-labelledby=languageSelector><a class="dropdown-item nav-link languages-item" href=/posts><span class="fi fi-es"></span>
Español
</a><a class="dropdown-item nav-link languages-item" href=/en/posts><span class="fi fi-gb"></span>
English</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme"></a></div></li></ul></div></div><img src=/images/site/main-logo_hu_f8052c7b59e526d6.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_hu_f8052c7b59e526d6.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Búsqueda data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Blog</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/posts/electronica/> Electrónica</a><ul><li><a class=list-link href=/posts/electronica/qu%C3%A9-es-una-pcb-y-c%C3%B3mo-mandarlas-a-hacer/ title="¿Qué es una PCB?">¿Qué es una PCB?</a></li><li><a class=list-link href=/posts/electronica/qu%C3%A9-es-un-circuito-antirrebote/ title="¿Qué es un circuito antirrebote?">¿Qué es un circuito antirrebote?</a></li><li><a class=list-link href=/posts/electronica/puente-h-con-relevadores-controla-un-motor-dc-con-arduino/ title="Puente H con relevadores">Puente H con relevadores</a></li><li><a class=list-link href=/posts/electronica/qu%C3%A9-es-mqtt-y-por-qu%C3%A9-se-usa-tanto-en-iot/ title="MQTT en pocas palabras">MQTT en pocas palabras</a></li><li><a class=list-link href=/posts/electronica/qu%C3%A9-es-opc-ua-y-por-qu%C3%A9-es-clave-en-la-automatizaci%C3%B3n-industrial/ title="OPC UA en contexto">OPC UA en contexto</a></li><li><a class=list-link href=/posts/electronica/qu%C3%A9-es-un-motor-a-pasos-y-c%C3%B3mo-aprovecharlo/ title="Motores a pasos">Motores a pasos</a></li><li><a class=list-link href=/posts/electronica/pull-up-vs-pull-down/ title="Pull-up vs pull-down">Pull-up vs pull-down</a></li><li><a class=list-link href=/posts/electronica/c%C3%B3mo-escoger-bater%C3%ADas/ title="Cómo escoger baterías">Cómo escoger baterías</a></li><li><a class=list-link href=/posts/electronica/cambiadores-de-rango-con-op-amps/ title="Cambiadores de rango con op-amps">Cambiadores de rango con op-amps</a></li><li><a class=list-link href=/posts/electronica/protecci%C3%B3n-contra-inversi%C3%B3n-de-polaridad/ title="Protección contra inversión de polaridad">Protección contra inversión de polaridad</a></li><li><a class=list-link href=/posts/electronica/capacitancia-parasitaria-en-pcbs/ title="Capacitancia parasitaria en PCBs">Capacitancia parasitaria en PCBs</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/microcontroladores/> Microcontroladores</a><ul><li><a class=list-link href=/posts/microcontroladores/raspberry-pi-pico/ title="Raspberry Pi Pico">Raspberry Pi Pico</a></li><li><a class=list-link href=/posts/microcontroladores/elegir-la-esp32-adecuada/ title="Elegir la ESP32 adecuada">Elegir la ESP32 adecuada</a></li><li><a class=list-link href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ title="Módulos PIO en la Pico">Módulos PIO en la Pico</a></li><li><a class=list-link href=/posts/microcontroladores/programar-la-pico-en-c-/ title="Programar la Pico en C++">Programar la Pico en C++</a></li><li><a class=list-link href=/posts/microcontroladores/ampliar-entradas-digitales-con-i2c/ title="Ampliar entradas digitales con I2C">Ampliar entradas digitales con I2C</a></li><li><a class=list-link href=/posts/microcontroladores/instalar-micro-ros-en-la-pico/ title="Instalar micro-ROS en la Pico">Instalar micro-ROS en la Pico</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/comunicaciones/> Comunicaciones</a><ul><li><a class=list-link href=/posts/comunicaciones/meshtastic-explicado/ title="Meshtastic explicado">Meshtastic explicado</a></li><li><a class=list-link href=/posts/comunicaciones/controlar-un-led-con-esp32-y-mqtt/ title="Controlar un LED con ESP32 y MQTT">Controlar un LED con ESP32 y MQTT</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/sensores/> Sensores</a><ul><li><a class=list-link href=/posts/sensores/encoders/ title=Encoders>Encoders</a></li><li><a class=list-link href=/posts/sensores/sensores-hall/ title="Sensores Hall">Sensores Hall</a></li><li><a class=list-link href=/posts/sensores/sensores-ultras%C3%B3nicos/ title="Sensores ultrasónicos">Sensores ultrasónicos</a></li><li><a class=list-link href=/posts/sensores/lidar/ title=Lidar>Lidar</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/robotica/> Robótica</a><ul><li><a class=list-link href=/posts/robotica/herramientas-indispensables-para-ros-2/ title="Herramientas ROS 2">Herramientas ROS 2</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/software/> Software</a><ul><li><a class=list-link href=/posts/software/transcribir-audio-con-whisper/ title="Transcribir audio con Whisper">Transcribir audio con Whisper</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/hardware-digital/> Hardware digital</a><ul><li><a class=list-link href=/posts/hardware-digital/fpgas/ title=FPGAs>FPGAs</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href> linux</a><ul><li><a class=list-link href=/posts/c%C3%B3mo-instalar-ubuntu-24.04-en-windows-11-con-wsl2-paso-a-paso/ title="Ubuntu 24.04 en WSL">Ubuntu 24.04 en WSL</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><div class=card><div class=card-head><a href=/posts/electronica/cambiadores-de-rango-con-op-amps/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/electronica/cambiadores-de-rango-con-op-amps/ class=post-card-link><h5 class=card-title>Cambiadores de rango con op-amps</h5><p class="card-text post-summary">Cuando un sensor entrega una señal fuera del rango de tu ADC o instrumento, necesitas un cambiador de rango. Con amplificadores operacionales puedes desplazar y escalar niveles para aprovechar mejor la resolución disponible.
Objetivo de diseño Queremos transformar una señal (V_{in}) en (V_{out}) según:
[ V_{out} = a V_{in} + b ]
donde (a) es la ganancia y (b) el offset. Un circuito sumador/restador con op-amp no inversor logra este comportamiento.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/amplificadores-operacionales/ class="btn btn-sm btn-info">Amplificadores operacionales</a></li><li class=rounded><a href=/tags/acondicionamiento-de-se%C3%B1al/ class="btn btn-sm btn-info">Acondicionamiento de señal</a></li><li class=rounded><a href=/tags/instrumentaci%C3%B3n/ class="btn btn-sm btn-info">Instrumentación</a></li><li class=rounded><a href=/tags/dise%C3%B1o-anal%C3%B3gico/ class="btn btn-sm btn-info">Diseño analógico</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/electronica/cambiadores-de-rango-con-op-amps/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/software/transcribir-audio-con-whisper/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/software/transcribir-audio-con-whisper/ class=post-card-link><h5 class=card-title>Transcribir audio con Whisper</h5><p class="card-text post-summary">Whisper es un modelo de reconocimiento de voz multilingüe de código abierto creado por OpenAI. Permite transcribir audio a texto con alta precisión sin depender de servicios en la nube.
Requisitos Python 3.8 o superior. Pip y virtualenv. FFmpeg instalado en el sistema (necesario para convertir formatos de audio). GPU opcional (CUDA) para acelerar inferencias con modelos grandes. Instala FFmpeg en Linux con sudo apt install ffmpeg o usa los binarios oficiales en Windows/macOS.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/whisper/ class="btn btn-sm btn-info">Whisper</a></li><li class=rounded><a href=/tags/python/ class="btn btn-sm btn-info">Python</a></li><li class=rounded><a href=/tags/transcripci%C3%B3n/ class="btn btn-sm btn-info">Transcripción</a></li><li class=rounded><a href=/tags/ia/ class="btn btn-sm btn-info">IA</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/software/transcribir-audio-con-whisper/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/sensores/lidar/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/sensores/lidar/ class=post-card-link><h5 class=card-title>Lidar</h5><p class="card-text post-summary">Los sistemas Lidar (Light Detection and Ranging) miden distancias con láser y generan mapas de alta resolución. Son esenciales en SLAM, vehículos autónomos e inspección industrial.
Tecnologías principales Lidar rotativo 2D: un láser gira 360° en un plano horizontal. Ejemplos: RPLidar A2, Hokuyo UST. Lidar rotativo 3D: varias líneas láser (Velodyne, Ouster) o inclinación mecánica para generar nubes 3D. Solid-state (MEMS, flash, FMCW): sin partes móviles, menor tamaño y costo creciente en automoción. Time-of-Flight directo vs FMCW: ToF mide tiempo, FMCW mide frecuencia y obtiene velocidad relativa. Parámetros clave Alcance: distancia máxima efectiva para objetos con reflectividad estándar. Frecuencia de escaneo: Hz o RPM; determina cuántos datos por segundo. Resolución angular: separación entre mediciones; influye en densidad de nube. Campo de visión (FoV): horizontal y vertical. Precisión y repetibilidad: error absoluto y ruido entre mediciones. Clase láser: seguridad ocular (Clase 1 preferida para interiores). Comparativa rápida Modelo Tipo Alcance Frecuencia Nota destacada RPLidar A1 2D 12 m 5–10 Hz Económico para hobby, sin protección polvo. Slamtec S1 2D 40 m 10–20 Hz IP65, lidar doble motor. Hokuyo UST-10LX 2D 10 m 40 Hz Industrial, interfaz Ethernet. Ouster OS1 3D solid-state 120 m 10–20 Hz Alta densidad, APIs ROS listas. Livox MID-360 3D no rotativo 70 m 20 Hz Escaneo no repetitivo con fusión temporal. Integración en robots Montaje rígido y calibración de transformaciones TF para ROS/ROS 2. Sincronización temporal con IMU o cámaras para SLAM preciso. Filtrado de ruido (VoxelGrid, StatisticalOutlierRemoval) antes de alimentar algoritmos. Gestión de energía: algunos modelos consumen >10 W, planifica la fuente. Buenas prácticas Mantén superficies limpias; polvo o insectos generan falsos positivos. Usa zonas de exclusión en software para ignorar partes del robot. Configura firmware y drivers oficiales para aprovechar actualizaciones de calibración. Considera climatización si operas en exterior (calentadores, deshumidificadores). Con estos criterios podrás elegir e integrar un Lidar acorde a tus necesidades de navegación y percepción.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/lidar/ class="btn btn-sm btn-info">Lidar</a></li><li class=rounded><a href=/tags/rob%C3%B3tica/ class="btn btn-sm btn-info">Robótica</a></li><li class=rounded><a href=/tags/slam/ class="btn btn-sm btn-info">SLAM</a></li><li class=rounded><a href=/tags/sensores-de-distancia/ class="btn btn-sm btn-info">Sensores de distancia</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/sensores/lidar/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/sensores/sensores-ultras%C3%B3nicos/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/sensores/sensores-ultras%C3%B3nicos/ class=post-card-link><h5 class=card-title>Sensores ultrasónicos</h5><p class="card-text post-summary">Los sensores ultrasónicos miden distancia calculando el tiempo que tarda un pulso acústico en viajar y regresar desde un obstáculo. Son económicos y útiles en robótica móvil, medición de nivel y domótica.
Componentes clave Transductor emisor/receptor piezoeléctrico (~40 kHz). Driver que genera burst de alta tensión (80–120 Vpp en modelos industriales). Detector de eco con amplificación logarítmica. Controlador que mide el tiempo de vuelo (ToF) y entrega una lectura digital o analógica. La distancia se calcula como:</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/ultras%C3%B3nico/ class="btn btn-sm btn-info">Ultrasónico</a></li><li class=rounded><a href=/tags/distancia/ class="btn btn-sm btn-info">Distancia</a></li><li class=rounded><a href=/tags/rob%C3%B3tica-m%C3%B3vil/ class="btn btn-sm btn-info">Robótica móvil</a></li><li class=rounded><a href=/tags/sensores/ class="btn btn-sm btn-info">Sensores</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/sensores/sensores-ultras%C3%B3nicos/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/sensores/sensores-hall/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/sensores/sensores-hall/ class=post-card-link><h5 class=card-title>Sensores Hall</h5><p class="card-text post-summary">El efecto Hall describe la diferencia de potencial que aparece cuando un conductor con corriente atraviesa un campo magnético. Los sensores Hall aprovechan este fenómeno para medir posición, velocidad o corriente sin contacto mecánico.
Tipos principales Hall digital tipo interruptor: salida on/off con histéresis. Usados en detección de proximidad, finales de carrera o conmutación de motores BLDC. Hall latch (bipolares): cambian de estado al detectar polos norte/sur, ideales para codificadores magnéticos. Hall lineales: entregan una tensión proporcional al campo (V_{out} = V_{ref} + S \cdot B), donde (S) es la sensibilidad. Sensores Hall de corriente: combinan un conductor y núcleo magnético para medir corriente en bus. Aplicaciones en motores Conmutación BLDC: tres sensores ubicados a 120° eléctricos generan la secuencia de activación de fases. Detección de rotor en motores paso a paso híbridos cuando se requiere feedback adicional. Protección contra sobrecorriente en drivers mediante Hall lineales integrados. Integración en encoders Encoders magnéticos como AS5048, MA730 o TLE5012 usan un imán diametral y sensores Hall 2D/3D. La resolución depende del ASIC (hasta 14 bits) y la alineación axial del imán. Proporcionan interfaces SPI, I²C, PWM o ABI (A/B/Z) compatibles con sistemas existentes. Diseño con sensores Hall Colocación del imán: asegura una distancia uniforme. Usa imanes diametrales o multipolares según la aplicación. Blindaje y ruido: filtra con capacitores y protege contra campos externos fuertes. Alimentación estable: muchos sensores usan referencias internas de 2,5 V; añade bypass de 100 nF + 1 µF. Calibración: aplica offsets y escalas vía firmware para corregir tolerancias. Selección del sensor Rango de campo: elige un dispositivo cuyo rango abarque tu campo máximo sin saturación. Sensibilidad y ruido: evalúa densidad espectral de ruido para mediciones precisas. Temperatura: para aplicaciones automotrices busca rangos -40 a 150 °C. Salida: digital open-drain, push-pull, analógica ratiométrica o PWM. Comprender estas variables te permitirá integrar sensores Hall de forma confiable en sistemas de motores, encoders y medición de corriente.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/sensores-hall/ class="btn btn-sm btn-info">Sensores Hall</a></li><li class=rounded><a href=/tags/motores/ class="btn btn-sm btn-info">Motores</a></li><li class=rounded><a href=/tags/encoders/ class="btn btn-sm btn-info">Encoders</a></li><li class=rounded><a href=/tags/magnetismo/ class="btn btn-sm btn-info">Magnetismo</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/sensores/sensores-hall/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/sensores/encoders/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/sensores/encoders/ class=post-card-link><h5 class=card-title>Encoders</h5><p class="card-text post-summary">Los encoders convierten movimiento en señales eléctricas para medir posición, velocidad o dirección. Son fundamentales en robótica, CNC y servo sistemas.
Clasificación principal Tipo Principio Resolución típica Ventajas Desventajas Incremental óptico Interrupción de luz LED-fotorreceptor 100–10.000 PPR Alta precisión, señales cuadratura. Sensibles al polvo, requieren referencia absoluta externa. Incremental magnético Sensor Hall/magnetorresistivo 32–2048 PPR Robustos, toleran suciedad. Menor precisión angular. Absoluto óptico Código Gray en disco 10–20 bits Posición única sin homing. Costosos, tamaño mayor. Absoluto magnético Sensor Hall 3D + ASIC 12–16 bits Compactos, soportan vibración. Requieren calibración precisa del imán. Lineales (regla óptica/magnética) Codificación incremental o absoluta 1–10 µm CNC y metrología. Instalación compleja. Señales y conexiones Cuadratura A/B: permite detectar dirección y multiplicar la resolución x4 con flancos. Index (Z): referencia una vuelta completa. Salida push-pull u open-collector: elige drivers compatibles con tu PLC o microcontrolador. Interfaces absolutas: SSI, BiSS-C, CANopen, EtherCAT, I²C/SPI en modelos compactos. Seleccionar un encoder Resolución necesaria: determina pulsos por revolución (PPR) o bits. Considera reducción mecánica y microstepping. Velocidad máxima: verifica frecuencia de salida (f = \text{PPR} \times \text{RPM} / 60) para dimensionar entradas. Ambiente: polvo, vibración, temperatura. Escoge IP adecuado y sellado. Montaje: eje sólido, hueco, sin rodamientos (kit encoder), acople flexible. Protocolo: compatibilidad con controladores existentes. Aplicaciones típicas Servomotores AC/DC con control de posición. Robots móviles para odometría diferencial. Impresoras 3D y CNC para realimentar husillos o camas. Instrumentación en metrología y mesas de inspección. Buenas prácticas Alinea mecánicamente el eje y usa acoples flexibles para evitar cargas radiales. Protege el cableado con pares trenzados y blindaje conectado a tierra por un extremo. Implementa homing seguro aun con encoders absolutos para validar límites físicos. Filtra ruido con entradas diferenciales (RS-422) y filtros digitales en firmware. Comprender estas variables te permitirá seleccionar el encoder adecuado y garantizar lecturas confiables en tus sistemas de control de movimiento.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/encoders/ class="btn btn-sm btn-info">Encoders</a></li><li class=rounded><a href=/tags/control-de-movimiento/ class="btn btn-sm btn-info">Control de movimiento</a></li><li class=rounded><a href=/tags/sensores/ class="btn btn-sm btn-info">Sensores</a></li><li class=rounded><a href=/tags/automatizaci%C3%B3n/ class="btn btn-sm btn-info">Automatización</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/sensores/encoders/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class=post-card-link><h5 class=card-title>Programar la Pico en C++</h5><p class="card-text post-summary">Programar la Raspberry Pi Pico directamente en C/C++ ofrece máximo control sobre el hardware y mejor desempeño que las capas de compatibilidad Arduino. Estos son los pasos clave para configurar el entorno oficial Pico SDK en Windows, Linux o macOS.
Requisitos previos Toolchain Arm GCC (arm-none-eabi-gcc y newlib). CMake ≥ 3.13 y Ninja o Make. Python 3 para scripts auxiliares. Git para clonar el SDK y submódulos. En Windows se recomienda usar WSL o el instalador oficial que empaqueta todas las dependencias.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/c++/ class="btn btn-sm btn-info">C++</a></li><li class=rounded><a href=/tags/pico-sdk/ class="btn btn-sm btn-info">Pico SDK</a></li><li class=rounded><a href=/tags/herramientas-de-desarrollo/ class="btn btn-sm btn-info">Herramientas de desarrollo</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/programar-la-pico-en-c-/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class=post-card-link><h5 class=card-title>Módulos PIO en la Pico</h5><p class="card-text post-summary">Los módulos PIO (Programmable I/O) del RP2040 permiten implementar periféricos programables sin cargar la CPU. Con dos bloques PIO y cuatro máquinas de estado cada uno, puedes crear controladores para protocolos no soportados de forma nativa.
Arquitectura PIO Máquinas de estado: hasta 4 por bloque, cada una con 32 instrucciones de 16 bits. FIFO TX/RX: buffers de 4 palabras para intercambio con la CPU o DMA. Pins flexibles: mapeo independiente para entrada, salida y side-set. Clock divider: ajusta la frecuencia de ejecución con resolución fraccional. Flujo de trabajo Escribe el programa PIO en ensamblador específico (.program). Carga el código en la instrucción memory del bloque PIO. Configura los registros de control (SM, clocks, pins). Usa la API del SDK o MicroPython para enviar/recibir datos. Ejemplos prácticos WS2812 (NeoPixel) Genera los pulsos de 800 kHz con side-set para controlar tiras RGB. Libera a la CPU para calcular animaciones mientras PIO gestiona la temporización. Interfaces VGA/DVI Emite señales de sincronía y datos de vídeo usando múltiples máquinas coordinadas. Requiere DMA para alimentar los buffers a alta velocidad. Captura de señales Configura una máquina PIO en modo IN para muestrear pines a alta frecuencia. Vuelca los datos a memoria mediante DMA para análisis posterior. Consejos de implementación Planifica el ancho de palabra. Ajusta push/pull y shift registers para empaquetar datos eficientemente. Utiliza DMA. Mantiene alimentadas las FIFOs sin bloquear la CPU. Divide funciones entre máquinas. Un bloque puede generar reloj y otro manejar datos. Depura con pioasm. El SDK incluye herramientas para validar el programa antes de compilar. Sincroniza con IRQ. Usa interrupciones PIO para coordinar eventos con el firmware principal. Recursos adicionales Documentación oficial del RP2040 Datasheet (capítulo PIO). Ejemplos del Pico SDK (pio/): UART, I²C, PWM mejorado, DVI. Librerías comunitarias como rp2040-pio-emulator para pruebas en PC. Dominar PIO te permitirá extender la Raspberry Pi Pico más allá de sus periféricos estándar y construir soluciones de tiempo real personalizadas.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/pio/ class="btn btn-sm btn-info">PIO</a></li><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/rp2040/ class="btn btn-sm btn-info">RP2040</a></li><li class=rounded><a href=/tags/protocolos-personalizados/ class="btn btn-sm btn-info">Protocolos personalizados</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/m%C3%B3dulos-pio-en-la-pico/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/comunicaciones/meshtastic-explicado/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/comunicaciones/meshtastic-explicado/ class=post-card-link><h5 class=card-title>Meshtastic explicado</h5><p class="card-text post-summary">Meshtastic es un firmware open source que transforma radios LoRa de bajo costo en redes malladas para mensajería y telemetría sin infraestructura celular. Es ideal para actividades al aire libre, resiliencia ante desastres y proyectos comunitarios.
Arquitectura básica Radios LoRa basados en chip SX1262/SX1276 que operan en bandas ISM (433, 868, 915 MHz). Firmware Meshtastic sobre microcontroladores ESP32, nRF52 o RP2040. Topología mesh: cada nodo reenvía mensajes de manera asincrónica usando enrutamiento oportunista. Aplicaciones móviles (Android/iOS) y clientes CLI/desktop que se conectan vía Bluetooth o USB. Tipos de nodos Nodos personales: dispositivos portátiles con pantalla (LilyGO T-Beam, T-Echo) que envían textos y ubicación GPS. Nodos de infraestructura: placas alimentadas continuamente para ampliar cobertura (antenas externas, alta potencia). Nodos sensores: integran telemetría (temperatura, humedad, relés) y reportan periódicamente. Configuración inicial Instala el firmware con Meshtastic Flasher o meshtastic --flash. Empareja el dispositivo con la app móvil mediante Bluetooth o USB. Ajusta canal, región y potencia según normativa local (duty cycle, ERP). Define roles (router, client) y habilita características como MQTT bridge o almacenamiento en tarjeta SD. Funciones destacadas Mensajería encriptada con AES-CTR y claves compartidas. Posicionamiento GPS y compartición de coordenadas con iconos personalizados. Bridge MQTT/HTTP para integrar con servidores o dashboards remotos. Telemetría extendida a través de plugins Python (meshtastic-python). Casos de uso Equipos de senderismo, ciclismo o rescate que requieren comunicación sin cobertura celular. Redes comunitarias de alerta temprana (incendios, inundaciones). IoT rural con nodos alimentados por energía solar. Eventos temporales donde se necesita mensajería descentralizada. Buenas prácticas Utiliza antenas calibradas y respeta la polarización para maximizar alcance. Configura intervalos de retransmisión adecuados para evitar congestión en mallas densas. Documenta claves y canales en un gestor seguro para tu equipo. Mantén el firmware actualizado y participa en la comunidad de GitHub/Discord para aprovechar nuevas funciones. Con esta visión podrás planear una red Meshtastic confiable y adaptarla a tus necesidades de comunicación de largo alcance.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/lora/ class="btn btn-sm btn-info">LoRa</a></li><li class=rounded><a href=/tags/mesh-networks/ class="btn btn-sm btn-info">Mesh networks</a></li><li class=rounded><a href=/tags/comunicaciones/ class="btn btn-sm btn-info">Comunicaciones</a></li><li class=rounded><a href=/tags/iot/ class="btn btn-sm btn-info">IoT</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/comunicaciones/meshtastic-explicado/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/robotica/herramientas-indispensables-para-ros-2/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/robotica/herramientas-indispensables-para-ros-2/ class=post-card-link><h5 class=card-title>Herramientas indispensables para ROS 2</h5><p class="card-text post-summary">ROS 2 ofrece múltiples utilidades para monitorear tópicos, analizar logs y depurar sistemas distribuidos. Conocer las herramientas correctas acelera el desarrollo y evita perder horas persiguiendo bugs.
Línea de comandos ros2 topic: inspecciona publicadores, suscriptores y contenido en tiempo real (ros2 topic echo, ros2 topic hz). Útil para validar tipos de mensajes y latencias. ros2 node: lista nodos activos, interfaces y parámetros expuestos. ros2 param: permite leer/escribir parámetros dinámicos, ideal para ajustar PIDs o constantes sin recompilar. ros2 bag: registra y reproduce mensajes DDS para depuración offline o análisis de regresiones. Visualización 3D con RViz RViz es la navaja suiza para visualizar mapas, nubes de puntos y frames TF.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/ros-2/ class="btn btn-sm btn-info">ROS 2</a></li><li class=rounded><a href=/tags/rob%C3%B3tica/ class="btn btn-sm btn-info">Robótica</a></li><li class=rounded><a href=/tags/herramientas-de-depuraci%C3%B3n/ class="btn btn-sm btn-info">Herramientas de depuración</a></li><li class=rounded><a href=/tags/visualizaci%C3%B3n-de-datos/ class="btn btn-sm btn-info">Visualización de datos</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/robotica/herramientas-indispensables-para-ros-2/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class=post-card-link><h5 class=card-title>Elegir la ESP32 adecuada</h5><p class="card-text post-summary">La familia ESP32 de Espressif incluye docenas de variantes con diferentes radios, memoria y encapsulados. Escoger el módulo correcto evita limitaciones de memoria, consumo excesivo o falta de certificaciones inalámbricas.
Criterios de selección Conectividad inalámbrica. ¿Necesitas Wi-Fi 2,4 GHz, Bluetooth LE, Classic o incluso 802.15.4? Memoria y almacenamiento. Flash integrada (4–16 MB), PSRAM opcional para buffers gráficos o voz. GPIO disponibles. Algunos módulos comparten pines con la antena o el cristal, reduciendo los I/O libres. Certificaciones. Para productos finales busca módulos con FCC/CE y antena integrada. Consumo energético. Evalúa modos de suspensión, corriente en deep sleep y voltaje operativo. Variantes populares Módulo CPU RAM/Flash Radios Características clave ESP32-WROOM-32 Xtensa LX6 dual a 240 MHz 520 KB + 4 MB flash Wi-Fi + BT Classic/LE DevkitC, amplio soporte, antena PCB. ESP32-WROVER Xtensa LX6 dual 520 KB + 4 MB flash + 8 MB PSRAM Wi-Fi + BT Ideal para gráficos, cámaras o SSL pesado. ESP32-C3 RISC-V single 160 MHz 400 KB + 4 MB flash Wi-Fi + BT LE 5 Bajo consumo, pin-to-pin con ESP8266. ESP32-S3 Xtensa LX7 dual 240 MHz 512 KB + 8 MB flash/PSRAM Wi-Fi + BT LE 5 Vector instructions para IA, USB OTG. ESP32-C6 RISC-V single 160 MHz 512 KB + 4 MB flash Wi-Fi 6 + BT LE 5 + 802.15.4 Thread/Matter listo, eficiente. Devkits recomendados ESP32-DevKitC: Referencia básica para WROOM. Incluye convertidor USB-UART y fácil acceso a pines. ESP32-S3-DevKitC-1: Para proyectos de visión gracias a USB nativo y soporte para cámaras. ESP32-C3-DevKitM-1: Ideal para wearables y sensores de baja potencia. LilyGO T-Display / T-Embed: Añaden pantalla IPS, ranura microSD y batería LiPo integrada. Consejos prácticos Define primero la pila de software. ESP-IDF, Arduino Core, MicroPython o circuitos con Matter pueden requerir memoria adicional. Revisa el pinout oficial. Algunos GPIO no toleran 5 V o están reservados para arranque (GPIO0, GPIO2, GPIO15). Planea la antena. Respeta el keep-out de la PCB o el conector U.FL para no degradar la potencia. Aprovecha los modos de bajo consumo. Configura RTC, ULP y wake-up por GPIO o temporizador para aplicaciones alimentadas por batería. Certifica tu producto. Usa módulos pre-certificados y documenta las pruebas de radiofrecuencia. Con esta matriz podrás elegir el módulo ESP32 que mejor se ajuste a tu presupuesto, consumo y requisitos de conectividad.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/esp32/ class="btn btn-sm btn-info">ESP32</a></li><li class=rounded><a href=/tags/iot/ class="btn btn-sm btn-info">IoT</a></li><li class=rounded><a href=/tags/wi-fi/ class="btn btn-sm btn-info">Wi-Fi</a></li><li class=rounded><a href=/tags/bluetooth/ class="btn btn-sm btn-info">Bluetooth</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/elegir-la-esp32-adecuada/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/microcontroladores/raspberry-pi-pico/ class=post-card-link><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/posts/microcontroladores/raspberry-pi-pico/ class=post-card-link><h5 class=card-title>Raspberry Pi Pico</h5><p class="card-text post-summary">La Raspberry Pi Pico es la primera placa oficial basada en el microcontrolador RP2040 de la Fundación Raspberry Pi. Combina precio contenido, doble núcleo Cortex-M0+ y periféricos flexibles que la convierten en una plataforma ideal para proyectos embebidos y de enseñanza.
Especificaciones esenciales Microcontrolador: RP2040 con dos núcleos Arm Cortex-M0+ a 133 MHz (overclock estable hasta ~250 MHz). Memoria: 264 KB de SRAM repartida en bancos y hasta 16 MB de flash externa QSPI. Periféricos: 30 GPIO, 2×USB 1.1, 2×UART, 2×I²C, 2×SPI, 16 canales PWM, ADC de 12 bits, 8 máquinas PIO. Alimentación: 1,8–5,5 V, regulador buck-boost integrado. Formatos: Pico estándar, Pico W (Wi-Fi), Pico H (headers soldados) y módulos embebibles. Fortalezas del RP2040 PIO (Programmable I/O). Motores de estado que permiten implementar protocolos personalizados a nivel de hardware. Doble núcleo. Separar tareas críticas en un core mientras el otro maneja lógica de alto nivel. Bajo costo y disponibilidad. La placa base ronda los 4 USD. Comunidad y documentación amplia. SDK en C/C++, MicroPython, CircuitPython y ejemplos oficiales. Casos de uso recomendados Controladores de robots educativos gracias a su PWM abundante y soporte MicroPython. Interfaces personalizadas (DVI, VGA, audio PDM) mediante PIO. IoT económico con el modelo Pico W y su módulo Wi-Fi CYW43439. Instrumentos de laboratorio DIY como generadores de señales y analizadores lógicos. Ecosistema de software Pico SDK (C/C++). Acceso directo al hardware con CMake, soporte para FreeRTOS y drivers oficiales. MicroPython y CircuitPython. Repl inmediato, ideal para iterar rápido. TinyUSB. Implementaciones de dispositivos USB (CDC, HID, MIDI) listas para usar. Bibliotecas de terceros. Drivers para pantallas, sensores y motores mantenidos por la comunidad. Consejos para proyectos Usa el SMPS integrado (VSYS) para alimentar sensores de 3,3 V y evita exceder 300 mA. Aprovecha el debug por SWD expuesto en los pads debajo de la placa. Para aplicaciones críticas, añade flash externa de calidad y watchdog habilitado. Documenta la versión del SDK en tu repositorio para reproducibilidad. Con estos puntos tendrás un panorama claro de lo que ofrece la Raspberry Pi Pico y podrás decidir cuándo utilizarla frente a otras opciones.</p></a><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/raspberry-pi-pico/ class="btn btn-sm btn-info">Raspberry Pi Pico</a></li><li class=rounded><a href=/tags/rp2040/ class="btn btn-sm btn-info">RP2040</a></li><li class=rounded><a href=/tags/microcontroladores/ class="btn btn-sm btn-info">Microcontroladores</a></li><li class=rounded><a href=/tags/prototipado/ class="btn btn-sm btn-info">Prototipado</a></li></ul></div></div><div class=card-footer><span class=float-start>sábado, 16 de marzo de 2024
| 2 minutos </span><a href=/posts/microcontroladores/raspberry-pi-pico/ class="float-end btn btn-outline-info btn-sm">Leer</a></div></div></div></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class="page-item active"><a aria-current=page aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/posts/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/3/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/3/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navegación</h5><ul><li class=nav-item><a class=smooth-scroll href=https://ingeniummx.github.io/#about>Acerca de</a></li><li class=nav-item><a class=smooth-scroll href=https://ingeniummx.github.io/#recent-posts>Posts</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contacto</h5><ul><li><a href=mailto:ingenium.mex01@gmail.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>ingenium.mex01@gmail.com</span></a></li><li><a href=https://github.com/ingeniummx target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>ingeniummx</span></a></li><li><a href=https://www.linkedin.com/in/ingenium-mx target=_blank rel=noopener><span><i class="fab fa-linkedin"></i></span> <span>Ingenium Mx</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu_b3360284c55cf72d.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2025 Ingenium Mx. Todos los derechos reservados.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Funcionando con
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.8db5b0dfda15f470a64b8c7de3b5be444659ae73f75bc4ede628de3ad8bd54a9.js integrity="sha256-jbWw39oV9HCmS4x947W+REZZrnP3W8Tt5ijeOti9VKk=" defer></script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=ingeniummx data-description="Support me on Buy me a coffee!" data-message="Buy me a coffee!" data-color=#FFDD00 data-position=Right data-x_margin=10 data-y_margin=18></script></body></html>